{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introducing PyMapManager","text":"<p>We introduce PyMapManager</p>"},{"location":"about/","title":"About PyMapManager","text":"<p>PyMapManager is under active development by a team of biologists and computer scientists at UC Davis.</p> <p>Including</p> <ul> <li>Robert</li> <li>Vasudha</li> <li>Johnson</li> <li>Suhayb</li> </ul>"},{"location":"download/","title":"Download","text":"<p>One file downloads for macOS and Windows are in the works. Check back again!</p>"},{"location":"install/","title":"Install From Command Line","text":"<p>Install from the command line</p> <p>make an env</p> <p>clone</p> <p>pip install</p> <p>get raw data</p> <p>run the GUI</p>"},{"location":"plugins/","title":"Plugins","text":"<p>PyMapManager is built from the ground up to be extensible with multiple types of plugins.</p> <ul> <li>File Loaders</li> <li>Analysis</li> <li>Visualizations</li> </ul>"},{"location":"plugins/#stack-plugins","title":"Stack Plugins","text":""},{"location":"plugins/#point-list","title":"Point List","text":""},{"location":"plugins/#segment-list","title":"Segment List","text":""},{"location":"api/map/","title":"map","text":""},{"location":"api/map/#pymapmanager.mmMap-classes","title":"Classes","text":""},{"location":"api/map/#pymapmanager.mmMap.mmMap","title":"<code>mmMap</code>","text":"<p>A time-series of :class:<code>pymapmanager.mmStack</code> time-points plus some book-keeping to link corresponding annotations and segments between time-points.</p> <p>Args:     filePath (str):         Either: Full path to map folder.         Or: Full file path to .txt file for the map. File is inside map folder, for map a5n it is '/a5n/a5n.txt'.     urlmap (str): Name of the map to load from a :class:<code>pymapmanager.mmio</code> online repository.</p> <p>Example::</p> <pre><code>from pymapmanager import mmMap\nmyMapPath = 'PyMapManager/examples/exampleMaps/rr30a'\nmyMap = mmMap(filePath=myMapPath)\n\n# Get the 3rd mmStack using\nstack = myMap.stacks[3]\n\n# Retrieve annotations (for a given segmentID) across all time-points in the map\npDist_values = myMap.getMapValues2('pDist', segmentID=[3])\n</code></pre> Source code in <code>pymapmanager/mmMap.py</code> <pre><code>class mmMap():\n    \"\"\"\n    A time-series of :class:`pymapmanager.mmStack` time-points plus some book-keeping to link corresponding annotations\n    and segments between time-points.\n\n    Args:\n        filePath (str):\n            Either: Full path to map folder.\n            Or: Full file path to .txt file for the map. File is inside map folder, for map a5n it is '/a5n/a5n.txt'.\n        urlmap (str): Name of the map to load from a :class:`pymapmanager.mmio` online repository.\n\n    Example::\n\n        from pymapmanager import mmMap\n        myMapPath = 'PyMapManager/examples/exampleMaps/rr30a'\n        myMap = mmMap(filePath=myMapPath)\n\n        # Get the 3rd mmStack using\n        stack = myMap.stacks[3]\n\n        # Retrieve annotations (for a given segmentID) across all time-points in the map\n        pDist_values = myMap.getMapValues2('pDist', segmentID=[3])\n    \"\"\"\n\n    def getStackPath(self, sessionIdx : int):\n        _folder, _file = os.path.split(self.filePath)\n        defaultChannel = 2\n        # /Users/cudmore/Sites/PyMapManager-Data/maps/rr30a/rr30a_s3_ch2.tif\n        stackName = self._getStackName(sessionIdx)\n        stackName = f'{stackName}_ch{defaultChannel}.tif'\n        stackPath = os.path.join(_folder, stackName)\n        return stackPath\n\n    def getStackTimepoint(self, thisStack : pymapmanager.stack) -&gt; int:\n        \"\"\"Given a stack, find the timepoint.\n        \"\"\" \n        for idx, stack in enumerate(self.stacks):\n            if stack == thisStack:\n                return idx\n        return None\n\n    def getMapName(self):\n        _folder, _name = os.path.split(self.filePath)\n        _name, _ext = os.path.splitext(_name)\n        return _name\n\n    def __init__(self, filePath=None, urlmap=None):\n        startTime = time.time()\n\n        self.filePath = ''\n        # Full file path to .txt file for the map.\n\n        self._folder = ''\n        # Path to enclosing folder, ends in '/'.\n\n        self.name = ''\n        # Name of the map. For a map loaded with file a5n.txt, name is a5b. Same as enclosing folder name.\n        # If urlmap then this is the name of the map to fetch from a :class:`pymapmanager.mmio` server.\n\n        self.table = None\n        # Pandas dataframe loaded from .txt file filePath or 'header' if using :class:`pymapmanager.mmio`.\n        # Get values from this dataframe using getValue(name,sessionNumber)\n\n        # removed 20170107, replaced with xxx\n        # self.defaultRoiType = 'spineROI'\n        #self.defaultRoiTypeID = 0\n\n        self.server = None\n        # Pointer to :class:`pymapmanager.mmio` server connection.\n        # Only used to load from urlmap.\n\n        self.objMap = None\n        # 2D array where each row is a run of annotations.\n        # objMap[i][j] gives us a mmStack centric index into mmStack.stackdb.\n\n        self.segMap = None\n        # 2D array where each row is a run of segments.\n        # segMap[i][j] gives us mmStack centric index into mmStack._line\n\n        self.segRunMap = None # 20180107, why was this not defaulted?\n\n        # if we get a filePath, make sure it exists and decide if it is a folder or a file\n        # in the end we will always load from a .txt file\n        if filePath is not None:\n            if filePath.endswith(os.sep):\n                filePath = filePath[0:-1]\n            if os.path.exists(filePath):\n                if os.path.isdir(filePath):\n                    tmpPath, tmpName = os.path.split(filePath)\n                    filePath = os.path.join(filePath, tmpName + '.txt')\n                    # check if file exists\n                    if not os.path.isfile(filePath):\n                        raise IOError(ENOENT, 'mmMap got a bad map folder:', filePath)\n                else:\n                    pass\n            else:\n                # error\n                raise IOError(ENOENT, 'mmMap got a bad map path:', filePath)\n\n        ###############################################################################\n        # map nv\n        doFile = True\n        if filePath is not None:\n            if not os.path.isfile(filePath):\n                raise IOError(ENOENT, 'mmMap did not find filePath:', filePath)\n            self.filePath = filePath #  Path to file used to open map.\"\"\"\n            self._folder = os.path.dirname(filePath) + '/'\n            self.name = os.path.basename(filePath).strip('.txt')\n            self.table = pd.read_table(filePath, index_col=0)\n        elif urlmap is not None:\n            doFile = False\n            # try loading from url\n            self.name = urlmap\n            self.server = mmio()\n            tmp = self.server.getfile('header', self.name)\n            self.table = pd.read_table(io.StringIO(tmp.decode('utf-8')), index_col=0)\n\n        ###############################################################################\n        # objMap (3d)\n        if doFile:\n            objMapFile = self._folder + self.name + '_objMap.txt'\n            if not os.path.isfile(objMapFile):\n                raise IOError(ENOENT, 'mmMap did not find objMapFile:', objMapFile)\n            # with open(objMapFile, 'rU') as f:\n            with open(objMapFile, 'r') as f:\n                header = f.readline().rstrip()\n            self.objMap = np.loadtxt(objMapFile, skiprows=1)\n        else:\n            tmp = self.server.getfile('objmap', self.name).decode(\"utf-8\")\n            header = tmp.split('\\n')[0]\n            self.objMap = np.loadtxt(tmp.split('\\n'), skiprows=1)\n\n        if header.endswith(';'):\n            header = header[:-1]\n        header = header.split(';')\n        d = dict(s.split('=') for s in header)\n        numRow = int(d['rows'])\n        numCol = int(d['cols'])\n        numBlock = int(d['blocks'])\n\n        self.objMap.resize(numBlock,numRow,numCol)\n        self.runMap = self._buildRunMap(self.objMap, roiTypeID=self.defaultAnnotationID)\n\n        ###############################################################################\n        # segMap (3d)\n        header = None\n        if doFile:\n            segMapFile = self._folder + self.name + '_segMap.txt'\n            if os.path.isfile(segMapFile):\n                # with open(segMapFile, 'rU') as f:\n                with open(segMapFile, 'r') as f:\n                    header = f.readline().rstrip()\n                self.segMap = np.loadtxt(segMapFile, skiprows=1)\n            else:\n                #raise IOError(ENOENT, 'mmMap did not find segMapFile:', segMapFile)\n                print('did not find segment map file, should be ok')\n        else:\n            tmp = self.server.getfile('segmap', self.name).decode(\"utf-8\")\n            #header = tmp.split('\\r')[0] # works when server is running on OSX\n            header = tmp.split('\\n')[0]\n            self.segMap = np.loadtxt(tmp.split('\\n'), skiprows=1)\n\n        if header is not None:\n            if header.endswith(';'):\n                header = header[:-1]\n            header = header.split(';')\n            d = dict(s.split('=') for s in header)\n            numRow = int(d['rows'])\n            numCol = int(d['cols'])\n            numBlock = int(d['blocks'])\n\n            self.segMap.resize(numBlock,numRow,numCol)\n            self.segRunMap = self._buildRunMap(self.segMap, roiTypeID = None)\n\n        ###############################################################################\n        #load each stack db\n        # this assumes self.objMap has already been loaded\n        self._stacks = [] #  A list of mmStack\n        for _session in range(0, self.numSessions):\n            stackPath = self.getStackPath(_session)\n            stack = pymapmanager.stack(stackPath,\n                                       loadImageData=False,\n                                       mmMap=self,\n                                       mmMapSession=_session)\n            # if doFile:\n            #     stack = mmStack(name=self._getStackName(i), numChannels=self.numChannels, \\\n            #                     map=self, mapSession=i)\n            # else:\n            #     stack = mmStack(name=self._getStackName(i), numChannels=self.numChannels, \\\n            #                     map=self, mapSession=i, urlmap=self.name)\n            self.stacks.append(stack)\n\n        stopTime = time.time()\n        print('map', self.name, 'loaded in', round(stopTime-startTime,2), 'seconds.')\n\n        # 202402 need to add some columns to stack db\n        logger.warning('REMOVE THIS INGEST !!!!!!!!!')\n        from pymapmanager.interface2.mapWidgets._mapIngest import addDistance\n        addDistance(self)\n\n    def __iter__(self):\n        # this along with __next__ allow mmMap to iterate over stacks\n        self._iterIdx = 0\n        return self\n\n    def __next__(self):\n        # this along with __iter__ allow mmMap to iterate over stacks\n        if self._iterIdx &lt; self.numSessions:\n            x = self.stacks[self._iterIdx]\n            self._iterIdx += 1\n            return x\n        else:\n            raise StopIteration\n\n    # def __iter__(self):\n    #     i = 0\n    #     while i &lt; len(self.stacks):\n    #         yield self.stacks[i]\n    #         i += 1\n\n    @property\n    def numChannels(self):\n        \"\"\"\n        Number of image channels in each stack (must be the same for all stacks).\n        \"\"\"\n        return int(self.getValue('numChannels', 0))\n\n    @property\n    def numSessions(self):\n        \"\"\"\n            Number of sessions (timepoints) in the map (time-series).\n        \"\"\"\n        return int(self.table.loc['hsStack'].count())\n\n    @property\n    def stacks(self):\n        \"\"\"List of :class:`pymapmanager.mmStack` in the map.\n        \"\"\"\n        return self._stacks\n\n    @property\n    def numMapSegments(self):\n        \"\"\"The number of line segments in the map.\n        Corresponding segments are connected together with the segMap.\n        \"\"\"\n        if self.segMap is not None:\n            numSegments = self.segRunMap.shape[0]\n        else:\n            numSegments = 0\n        return numSegments\n\n    @property\n    def defaultAnnotation(self):\n        \"\"\"\n        \"\"\"\n        # if defaultAnnotation does not exist then default to 'spineROI'\n        if 'defaultAnnotation' in self.table.index:\n            theRet = self.table.loc['defaultAnnotation'][0]\n            # if empty then we assume 'spineROI'\n            if theRet == '':\n                theRet = 'spineROI'\n        else:\n            theRet = 'spineROI'\n        return theRet\n\n    @property\n    def defaultAnnotationID(self):\n        theRet = 0\n        defaultAnnotation = self.defaultAnnotation\n        if defaultAnnotation == 'spineROI':\n            theRet = 0\n        elif defaultAnnotation == 'otherROI':\n            theRet = 4\n        return theRet\n\n    def __str__(self):\n\n        objCount = 0\n        for stack in self.stacks:\n            objCount += len(stack.getPointAnnotations())\n\n        '''\n        theRet = {}\n        theRet['info'] = ('map:' + self.name\n            + ' map segments:' + str(self.numMapSegments)\n            + ' stacks:' + str(self.numSessions)\n            + ' total object:' + str(objCount))\n        theRet['map'] = self\n        '''\n        retStr = ('map:' + self.name\n            + ' map segments:' + str(self.numMapSegments)\n            + ' stacks:' + str(self.numSessions)\n            + ' total object:' + str(objCount))\n        return retStr\n\n    def getDataFrame(self):\n        df = pd.DataFrame()\n        df['Idx'] = range(self.numSessions)\n        df['File'] = [self._getStackName(tp) for tp in range(self.numSessions)]\n        return df\n\n    def mapInfo(self):\n        \"\"\"\n        Get information on the map\n\n        Returns:\n            | A dict of\n            | mapName : Str\n            | numSessions : Int\n            | numChannels : Int\n            | numMapSegments : Int\n            |\n            | The following are string list with numSessions elements\n            | stackNames :\n            | importedStackName :\n            | numSlices :\n            | date :\n            | time :\n            | dx : Voxel size in um\n            | dy : Voxel size in um\n            | dz : Voxel size in um\n            | px : Number of Pixels\n            | py : Number of Pixels\n            | pz : Number of Pixels\n            | ...\n        \"\"\"\n        theRet = {}\n        theRet['mapName'] = self.name\n        theRet['numSessions'] = self.numSessions\n        theRet['numChannels'] = self.numChannels\n        theRet['defaultAnnotation'] = self.defaultAnnotation\n        theRet['numAnnotations'] = 0\n        # lists, one value per session\n        theRet['stackNames'] = []\n        theRet['importedStackName'] = []\n        theRet['date'] = []\n        theRet['time'] = []\n        theRet['px'] = [] # pixels\n        theRet['py'] = []\n        theRet['numSlices'] = []\n        theRet['dx'] = [] # voxels in um\n        theRet['dy'] = []\n        theRet['dz'] = []\n        theRet['numROI'] = []\n        for idx in range(self.numSessions):\n            theRet['stackNames'].append(self.table.loc['hsStack'][idx])\n            theRet['importedStackName'].append(self.table.loc['importedStackName'][idx])\n            theRet['date'].append(self.table.loc['date'][idx])\n            theRet['time'].append(self.table.loc['time'][idx])\n            theRet['px'].append(self.table.loc['px'][idx])\n            theRet['py'].append(self.table.loc['py'][idx])\n            theRet['numSlices'].append(self.table.loc['pz'][idx]) # changing name\n\n            theRet['dx'].append(self.table.loc['dx'][idx])\n            theRet['dy'].append(self.table.loc['dy'][idx])\n            theRet['dz'].append(self.table.loc['dz'][idx])\n\n            thisNum = self.stacks[idx].countObj(roiType=self.defaultAnnotation)\n            theRet['numROI'].append(thisNum)\n            theRet['numAnnotations'] = theRet['numAnnotations'] + self.stacks[idx].numObj\n\n            runIdx = 6\n\n        if self.segMap is not None:\n            theRet['numMapSegments'] = self.segRunMap.shape[0]\n        else:\n            theRet['numMapSegments'] = 0\n\n        '''\n        # these were not being used\n        theRet['objMap'] = self.objMap[runIdx].astype('int') # from spine index to run index\n        theRet['runMap'] = self.runMap.astype('int') # from run idx to spine idx\n        theRet['segMap'] = None\n        theRet['numMapSegments'] = 0\n        if self.segMap is not None:\n            theRet['segMap'] = self.segMap.astype('int')\n            theRet['numMapSegments'] = self.segRunMap.shape[0]\n        '''\n\n        #print 'mapInfo() theRet:', theRet\n        return theRet\n\n    def getValue(self, name, sessionNumber):\n        \"\"\"\n        Get a value from the map (not from a stack!).\n\n        Args:\n            name: Name of map value\n            sessionNumber: Session number of the stack\n\n        Returns:\n            Str (this is a single value)\n\n        Examples::\n\n            m.getValue('pixelsz', 2) # get the number of z-slices (pixels) of stack 2.\n            m.getValue('voxelx', 5) # get the x voxel size of stack 5 (in um/pixel).\n            m.getValue('hsStack',3) # get the name of stack 3.\n        \"\"\"\n        # .loc specifies row, .iloc specifies a column\n        return self.table.loc[name].iloc[sessionNumber]\n\n    def _getStackName(self, session : int) -&gt; str:\n        \"\"\"Get the name of the stack at session.\n        \"\"\"\n        ret = self.getValue('hsStack', session)\n        if ret.endswith('_ch1') or ret.endswith('_ch2'):\n            ret = ret[:-4]\n        return ret\n\n    def getMapDynamics(self, pd, thisMatrix=None):\n\n        if thisMatrix is None:\n            pd = self.getMapValues3(pd)\n            thisMatrix = pd['stackidx']\n\n        # print(thisMatrix)\n        # _val = thisMatrix[0, 3]\n        # print(_val, type(_val), _val&gt;0, _val.astype(int))\n        # sys.exit(1)\n\n        nSpineRun = thisMatrix.shape[0]\n        nSessions = thisMatrix.shape[1]\n\n        pd['dynamics'] = np.empty([nSpineRun,nSessions])\n        pd['dynamics'][:] = np.NAN\n\n        # 1:add, 2:sub, 3:transient, 4:persisten\n        kAdd = 1\n        kSubtract = 2\n        kTransient = 3\n        kPersistent = 4\n\n        for i in range(nSpineRun):\n            for j in range(nSessions):\n                if not thisMatrix[i,j]&gt;=0:\n                    continue\n                if j == 0:\n                    # first session\n                    if thisMatrix[i,j+1]&gt;=0:\n                        pd['dynamics'][i,j] = kPersistent\n                    else:\n                        pd['dynamics'][i,j] = kSubtract\n                elif j == nSessions - 1:\n                    # last session\n                    if thisMatrix[i,j-1]&gt;=0:\n                        pd['dynamics'][i,j] = kPersistent\n                    else:\n                        pd['dynamics'][i,j] = kAdd\n                else:\n                    # middle session (not first or last)\n                    added = not thisMatrix[i,j-1] &gt;= 0\n                    subtracted = not thisMatrix[i,j+1] &gt;= 0\n                    if added and subtracted:\n                        pd['dynamics'][i,j] = kTransient\n                    elif added:\n                        pd['dynamics'][i,j] = kAdd\n                    elif subtracted:\n                        pd['dynamics'][i,j] = kSubtract\n                    else:\n                        pd['dynamics'][i,j] = kPersistent\n\n        # print(pd['dynamics'])\n        # sys.exit(1)\n\n        return pd\n\n    def ingest(self, tp, channel=1):\n        \"\"\"\n        Take a raw 3D .tif and populate raw/ingest/tp&lt;tp&gt; with single channel .tif files.\n\n        Args:\n            tp (int) : The timepoint to ingest\n            channel (int) : The channel to ingest, valid channels are (1,2,3)\n\n        Returns:\n            None\n        \"\"\"\n\n        print('mmMap.ingest() is ingesting tp:', tp, 'channel:', channel)\n\n        outFileType = '.png'\n\n        # '/Users/cudmore/Desktop/tmp/'\n        savePath = self._folder # ends in '/'\n        savePath += 'raw/'\n        if not os.path.isdir(savePath):\n            os.makedirs(savePath)\n        savePath += 'ingested/'\n        if not os.path.isdir(savePath):\n            os.makedirs(savePath)\n        savePath += 'tp' + str(tp) + '/'\n        if not os.path.isdir(savePath):\n            os.makedirs(savePath)\n\n        maxSavePath = self._folder + 'raw/ingested/'\n\n        print('   loading full 3d .tif')\n        # load the full 3D .tif\n        image = self.stacks[tp].loadStackImages(channel=channel)\n        print('   image shape:', image.shape)\n        [slices, m, n] = image.shape\n        for slice in range(slices):\n            outfile = self.name + '_tp' + str(tp) + '_ch' + str(channel) + '_s' + str(slice).zfill(4) + outFileType\n            outfilepath = savePath + outfile\n\n            if slice % 10 == 0:\n                print('   saving slice:', slice, 'of', slices, outfilepath)\n\n            # this saves .png as 8-bit, I am not sure if it is doing normalization?\n            scipy.misc.imsave(outfilepath, image[slice,:,:])\n\n        # make maximal intensity projection\n        maxfile = 'MAX_' + self.name + '_tp' + str(tp) + '_ch' + str(channel) + outFileType\n        maxfilepath = maxSavePath + maxfile\n        print('   making and saving max project', maxfilepath)\n        max_ = np.zeros((m, n), dtype='uint8')\n        for slice in range(slices):\n            max_ = np.maximum(max_, image[slice,:,:])\n        # MAX_rr30a_tp0_ch2\n        scipy.misc.imsave(maxfilepath, max_)\n\n        print('done ingesting')\n\n    def getMapValues3(self, pd):\n        \"\"\"Get values of a stack annotation across all stacks in the map.\n\n        Args:\n            pd (dict): A plot dictionary describing what to plot. Get default from mmUtil.newplotdict().\n\n        Returns:\n\n            | pd['x'], 2D ndarray of xstat values, rows are runs, cols are sessions, nan is where there is no stackdb annotation\n            | pd['y'], same\n            | pd['z'], same\n            | pd['stackidx'], Each [i]j[] gives the stack centric index of annotation value at [i][j].\n            | pd['mapsess'], Each [i][j] gives the map session of value at annotation [i][j].\n            | pd['runrow'],\n\n        \"\"\"\n        startTime = time.time()\n\n        # make sure pd['roitype'] is a list\n        if not isinstance(pd['roitype'], list):\n            pd['roitype'] = [pd['roitype']]\n\n        m = self.runMap.shape[0]\n        n = self.runMap.shape[1]\n\n        if pd['xstat']:\n            pd['x'] = np.empty([m, n])\n            pd['x'][:] = np.NAN\n        if pd['ystat']:\n            pd['y'] = np.empty([m, n])\n            pd['y'][:] = np.NAN\n        if pd['zstat']:\n            pd['z'] = np.empty([m, n])\n            pd['z'][:] = np.NAN\n\n        # keep track of stack centric index we are plotting\n        yIdx = np.empty([m, n])\n        yIdx[:] = np.NAN\n\n        # keep track of session index\n        ySess = np.empty([m, n])\n        ySess[:] = np.NAN\n\n        # keep track of run map rows (we already know the session/column)\n        yRunRow = np.empty([m, n])\n        yRunRow[:] = np.NAN\n\n        # always make a matrix of bad\n        isBad = np.empty([m, n])\n        isBad[:] = np.NAN\n\n        # keep track of map segment id\n        yMapSegment = []\n        if self.segMap is not None:\n            yMapSegment = np.empty([m, n])\n            yMapSegment[:] = np.NAN\n\n        # 20171225, cPnt is overkill but until I rewrite REST\n        # to get list of stat (x,y,z,pDist, cPnt, cx, cy, cz) etc. etc.\n        cPnt = np.empty([m, n])\n        cPnt[:] = np.NAN\n\n        runIdxDim = 6\n\n        if pd['stacklist'] is not None and len(pd['stacklist'])&gt;0:\n            myRange = pd['stacklist']\n        else:\n            myRange = range(n)\n\n        for j in myRange:\n\n            #print('*** getMapValues3() j:', j, \"pd['segmentid']:\", pd['segmentid'])\n            # orig_df = self.stacks[j].stackdb\n            orig_df = self.stacks[j].getPointAnnotations().getDataFrame()\n\n            # print(orig_df.columns)\n            # sys.exit(1)\n\n            currSegmentID = []\n            if self.numMapSegments &gt; 0:\n                # 20220103\n                oneSegment = pd['segmentid']\n                if isinstance(oneSegment, list):\n                    logger.warning('abb 20220103 in mmMap.getMapValue3() fix this cludge from list to int')\n                    if len(oneSegment) &gt; 0:\n                        oneSegment = oneSegment[0]\n                    else:\n                        oneSegment = None\n                if oneSegment is not None and oneSegment &gt;=0 :\n                    currSegmentID = self.segRunMap[oneSegment, j]  # this only works for one segment -- NOT A LIST\n                    #print('   currSegmentID:', currSegmentID)\n                    if currSegmentID &gt;= 0:\n                        currSegmentID = int(currSegmentID)\n                        # print 'getMapValues3() j:', j, 'currSegmentID:', currSegmentID\n                        currSegmentID = [currSegmentID]\n                    else:\n                        currSegmentID = []\n                #print('   currSegmentID:', currSegmentID)\n                if oneSegment is not None and oneSegment &gt;= 0 and not currSegmentID:\n                    # this session does not have segmentID that match\n                    #print('   getMapValues3() skipping tp', j)\n                    continue\n\n            goodIdx = self.runMap[:, j]  # valid indices from runMap\n\n            #print goodIdx\n\n            runMap_idx = orig_df.index.isin(goodIdx)  # series of boolean (Seems to play nice with nparray)\n\n            if pd['roitype']:\n                roiType_idx = orig_df['roiType'].isin(pd['roitype'])\n                runMap_idx = runMap_idx &amp; roiType_idx\n            if currSegmentID:\n                segmentID_idx = orig_df['segmentID'].isin(currSegmentID)\n                runMap_idx = runMap_idx &amp; segmentID_idx\n\n            # bad\n            if not pd['plotbad']:\n                #print('mmMap.getMapValues3() is stripping out isBad')\n                notBad_idx = ~orig_df['isBad'].isin([1])\n                runMap_idx = runMap_idx &amp; notBad_idx\n\n            # final_df = orig_df.loc[runMap_idx]\n            # 20210922 was this\n            #final_df = orig_df.ix[runMap_idx]\n            #print('20210922 orig_df:')\n            #print(orig_df)\n            final_df = orig_df.loc[runMap_idx]\n            #print(final_df)\n\n            # 20230523\n            _days = self.getValue('days', j)  # _days is a str\n            # logger.info(f'runMap_idx: {runMap_idx}')\n            final_df.loc[runMap_idx, 'days'] = _days\n\n            finalIndexList = final_df.index.tolist()\n\n            # we have a list of valid stack centric index in runMap_idx\n            # reverse this back into run centric to set rows in runMap (xPlot, yPlot)\n            # finalRows = self.objMap[runIdxDim,final_df.index,j]\n            finalRows = self.objMap[runIdxDim, finalIndexList, j]\n            finalRows = finalRows.astype(int)\n\n            #print 'getMapValues3() final_df:', final_df\n\n            # convert to values at end\n            try:\n                if pd['xstat'] and pd['xstat'] != 'session':\n                    pd['x'][finalRows, j] = final_df[pd['xstat']].values\n                if pd['ystat']:\n                    pd['y'][finalRows, j] = final_df[pd['ystat']].values\n                if pd['zstat']:\n                    pd['z'][finalRows, j] = final_df[pd['zstat']].values\n            except (KeyError) as e:\n                logger.error(f'getMapValues3() KeyError - {e}')\n            # except:\n            #     print('getMapValues3() error in assignment')\n\n            # keep track of stack centric spine idx\n            yIdx[finalRows, j] = final_df.index.values\n            ySess[finalRows, j] = j\n            yRunRow[finalRows, j] = finalRows  # final_df.index\n\n            # bad\n            if pd['plotbad']:\n                bad_idx = final_df['isBad'].isin([1])\n                '''\n                if j == 3:\n                    print(j, 'finalRows.shape:', finalRows.shape, finalRows.dtype)\n                    print(j, 'bad_idx.shape:', bad_idx.shape, bad_idx.dtype)\n                    print(final_df[['Idx', 'isBad']])\n                '''\n                isBad[finalRows, j] = bad_idx\n\n            #print 'a', final_df['parentID'].values.astype(int)\n            #print 'b', self.segMap[0, final_df['parentID'].values.astype(int), j]\n            if self.segMap is not None:\n                yMapSegment[finalRows, j] = self.segMap[0, final_df['segmentID'].values.astype(int), j]\n\n            cPnt[finalRows, j] = final_df['brightestIndex'].values\n\n            if pd['xstat'] == 'session':\n                #print 'swapping x for session'\n                pd['x'][finalRows, j] = j #ySess[finalRows,j]\n\n        # strip out all nan rows, can't do this until we have gone through all sessions\n        # makes plotting way faster\n        ySess = ySess[~np.isnan(yIdx).all(axis=1)]\n        yRunRow = yRunRow[~np.isnan(yIdx).all(axis=1)]\n        if pd['plotbad']:\n            isBad = isBad[~np.isnan(yIdx).all(axis=1)]\n        if self.segMap is not None:\n            yMapSegment = yMapSegment[~np.isnan(yIdx).all(axis=1)] # added 20171220\n        cPnt = cPnt[~np.isnan(yIdx).all(axis=1)] # added 20171225\n        if pd['xstat']:\n            pd['x'] = pd['x'][~np.isnan(yIdx).all(axis=1)]\n        if pd['ystat']:\n            pd['y'] = pd['y'][~np.isnan(yIdx).all(axis=1)]\n        if pd['zstat']:\n            pd['z'] = pd['z'][~np.isnan(yIdx).all(axis=1)]\n        yIdx = yIdx[~np.isnan(yIdx).all(axis=1)] # do this last\n\n\n        pd['stackidx'] = yIdx\n        pd['mapsess'] = ySess\n        pd['runrow'] = yRunRow\n        pd['mapsegment'] = yMapSegment\n        pd['cPnt'] = cPnt\n        if pd['plotbad']:\n            pd['isBad'] = isBad\n        else:\n            pd['isBad'] = None\n\n        if pd['getMapDynamics']:\n            # creates pd['dynamics']\n            pd = self.getMapDynamics(pd, thisMatrix=pd['stackidx'])\n\n        stopTime = time.time()\n        logger.info(f'   took:{round(stopTime - startTime, 2)} seconds')\n\n        return pd\n\n    def getMapValues2(self, stat, roiType=['spineROI'], segmentID=[], plotBad=False, plotIntBad=False):\n        \"\"\"Get values of a stack annotation across all stacks in the map.\n\n        Args:\n            stat (str): The stack annotation to get (corresponds to a column in mmStack.stackdb)\n            roiType (str): xxx\n            segmentID (list): xxx\n            plotBad (boolean): xxx\n\n        Returns:\n            2D numpy array of stat values. Each row is a run of objects connected across sessions,\n            columns are sessions, each [i][j] is a stat value\n        \"\"\"\n\n        #if roiType not in ROI_TYPES:\n        #    errStr = 'error: mmMap.getMapValues2() stat \"' + roiType + '\" is not in ' + ','.join(ROI_TYPES)\n        #    raise h(errStr)\n\n        plotDict = newplotdict()\n        plotDict['roitype'] = roiType\n        plotDict['xstat'] = stat\n        plotDict['segmentid'] = segmentID\n        plotDict['plotbad'] = plotBad\n        plotDict['plotIntBad'] = plotIntBad\n\n        plotDict = self.getMapValues3(plotDict)\n\n        return plotDict['x']\n\n    def _buildRunMap(self, theMap, roiTypeID=None):\n        \"\"\"Internal function.\n            Converts 3D objMap into a 2D run map.\n            A run map must be float as it uses np.NaN\n\n        Args:\n            theMap: Either self.objMap or self.segMap\n\n        Returns:\n            A numpy ndarray run map\n        \"\"\"\n\n        idx = 0\n        next = 1\n        #nexttp = 2\n        prev = 3\n        #prevtp = 4\n        runIdx = 6 #if this is correct we can build really fast\n        nodeType = 9 # integer encoding type, spineROI==0\n        m = theMap.shape[1]\n        n = theMap.shape[2]\n        k = theMap.shape[0]\n\n        # reset\n        theMap[runIdx][:][:] = '-1'\n\n        # 20171222\n        # was this\n        #numRows = np.count_nonzero(~np.isnan(theMap[idx,:,0]))\n        #retRunMap = np.empty([numRows,n]) #, dtype=int)\n        # new\n        retRunMap = np.empty([1, n])  #, dtype=int) # start as one row in run map\n        retRunMap[:] = 'nan'\n\n        emptyRow = np.empty([1, n])\n        emptyRow[:] = 'nan'\n\n        # thisroitype = 'spineROI'\n\n        currRow = 0\n        for j in range(0,n): #sessions\n            # not loaded yet\n            #stackdb = self.stacks[j].stackdb\n            if j == 0:\n                firstSessionAdded = 0\n            for i in range(0,m):\n                #retRunMap[i,j] = 'nan'\n                # 20171221, if i just break on ! roiType (e.g. spine) then we get a run map without nan rows?\n                # we need to add an updated %runIdx as we do this, e.g. theMap[runIdx][i][j]= currRow\n                # new\n                #if theMap[idx,i,j]&gt;=0 and stackdb[i][%roiType] == thisroitype:\n                #    pass\n                #else:\n                #    break\n                # was this\n                # if theMap[idx,i,j]&gt;=0:\n                if theMap[idx,i,j]&gt;=0 and (roiTypeID is None or theMap[nodeType][i][j] == roiTypeID):\n                    pass\n                else:\n                    continue\n                if j==0:\n                    '''\n                    # was this 20171222\n                    currRow = i\n                    #currRow = firstSessionAdded\n                    # new one line 20171222\n                    # retRunMap = np.vstack([retRunMap, emptyRow])\n                    retRunMap[currRow, j] = i\n                    # new\n                    #theMap[runIdx,i,j] = currRow\n                    '''\n\n                    if firstSessionAdded == 0:\n                        currRow = 0\n                        firstSessionAdded += 1\n                    else:\n                        retRunMap = np.vstack([retRunMap, emptyRow])\n                        currRow += 1\n                    retRunMap[currRow, j] = i\n                    # new\n                    theMap[runIdx,i,j] = currRow\n                elif not (theMap[prev,i,j]&gt;=0):\n                    currRow += 1\n                    retRunMap = np.vstack([retRunMap, emptyRow])\n                    retRunMap[currRow, j] = i\n                    # new\n                    theMap[runIdx,i,j] = currRow\n                else:\n                    continue\n                #retRunMap[currRow,j] = i\n                nextNode = theMap[next,i, j]\n                for k in range(j+1,n):\n                    if nextNode &gt;= 0:\n                        retRunMap[currRow,k] = nextNode\n                        # new, double check this\n                        theMap[runIdx,int(nextNode),k] = currRow\n                    else:\n                        break\n                    nextNode = theMap[next,int(nextNode),k]\n        return retRunMap\n\n    def _getStackSegmentID(self, mapSegmentNumber, sessIdx):\n        \"\"\"Given a map centric segment index (row in segRunMap),\n            return the stack centric segmentID for session sessIdx\n\n        Args:\n            mapSegmentNumber (int): Map centric segment index, row in segRunMap\n            sessIdx (int): Session number\n\n        Returns: int or nan: Stack centric segmentID or None if no corresponding segment in that session.\n        \"\"\"\n        stackSegment = np.nan\n        if self.segRunMap is not None:\n            stackSegment = self.segRunMap[mapSegmentNumber][sessIdx] # can be nan\n        if math.isnan(stackSegment):\n            return None\n        else:\n            return stackSegment\n\n    ####################################################\n    ## ingest\n    ####################################################\n    def ingest(self):\n        print('mmMap.ingest()', self)\n        for stack in self.stacks:\n            #print(stack)\n            stack.ingest()\n</code></pre>"},{"location":"api/map/#pymapmanager.mmMap.mmMap-attributes","title":"Attributes","text":""},{"location":"api/map/#pymapmanager.mmMap.mmMap.defaultAnnotation","title":"<code>defaultAnnotation</code>  <code>property</code>","text":""},{"location":"api/map/#pymapmanager.mmMap.mmMap.numChannels","title":"<code>numChannels</code>  <code>property</code>","text":"<p>Number of image channels in each stack (must be the same for all stacks).</p>"},{"location":"api/map/#pymapmanager.mmMap.mmMap.numMapSegments","title":"<code>numMapSegments</code>  <code>property</code>","text":"<p>The number of line segments in the map. Corresponding segments are connected together with the segMap.</p>"},{"location":"api/map/#pymapmanager.mmMap.mmMap.numSessions","title":"<code>numSessions</code>  <code>property</code>","text":"<p>Number of sessions (timepoints) in the map (time-series).</p>"},{"location":"api/map/#pymapmanager.mmMap.mmMap.stacks","title":"<code>stacks</code>  <code>property</code>","text":"<p>List of :class:<code>pymapmanager.mmStack</code> in the map.</p>"},{"location":"api/map/#pymapmanager.mmMap.mmMap-functions","title":"Functions","text":""},{"location":"api/map/#pymapmanager.mmMap.mmMap.__init__","title":"<code>__init__(filePath=None, urlmap=None)</code>","text":"Source code in <code>pymapmanager/mmMap.py</code> <pre><code>def __init__(self, filePath=None, urlmap=None):\n    startTime = time.time()\n\n    self.filePath = ''\n    # Full file path to .txt file for the map.\n\n    self._folder = ''\n    # Path to enclosing folder, ends in '/'.\n\n    self.name = ''\n    # Name of the map. For a map loaded with file a5n.txt, name is a5b. Same as enclosing folder name.\n    # If urlmap then this is the name of the map to fetch from a :class:`pymapmanager.mmio` server.\n\n    self.table = None\n    # Pandas dataframe loaded from .txt file filePath or 'header' if using :class:`pymapmanager.mmio`.\n    # Get values from this dataframe using getValue(name,sessionNumber)\n\n    # removed 20170107, replaced with xxx\n    # self.defaultRoiType = 'spineROI'\n    #self.defaultRoiTypeID = 0\n\n    self.server = None\n    # Pointer to :class:`pymapmanager.mmio` server connection.\n    # Only used to load from urlmap.\n\n    self.objMap = None\n    # 2D array where each row is a run of annotations.\n    # objMap[i][j] gives us a mmStack centric index into mmStack.stackdb.\n\n    self.segMap = None\n    # 2D array where each row is a run of segments.\n    # segMap[i][j] gives us mmStack centric index into mmStack._line\n\n    self.segRunMap = None # 20180107, why was this not defaulted?\n\n    # if we get a filePath, make sure it exists and decide if it is a folder or a file\n    # in the end we will always load from a .txt file\n    if filePath is not None:\n        if filePath.endswith(os.sep):\n            filePath = filePath[0:-1]\n        if os.path.exists(filePath):\n            if os.path.isdir(filePath):\n                tmpPath, tmpName = os.path.split(filePath)\n                filePath = os.path.join(filePath, tmpName + '.txt')\n                # check if file exists\n                if not os.path.isfile(filePath):\n                    raise IOError(ENOENT, 'mmMap got a bad map folder:', filePath)\n            else:\n                pass\n        else:\n            # error\n            raise IOError(ENOENT, 'mmMap got a bad map path:', filePath)\n\n    ###############################################################################\n    # map nv\n    doFile = True\n    if filePath is not None:\n        if not os.path.isfile(filePath):\n            raise IOError(ENOENT, 'mmMap did not find filePath:', filePath)\n        self.filePath = filePath #  Path to file used to open map.\"\"\"\n        self._folder = os.path.dirname(filePath) + '/'\n        self.name = os.path.basename(filePath).strip('.txt')\n        self.table = pd.read_table(filePath, index_col=0)\n    elif urlmap is not None:\n        doFile = False\n        # try loading from url\n        self.name = urlmap\n        self.server = mmio()\n        tmp = self.server.getfile('header', self.name)\n        self.table = pd.read_table(io.StringIO(tmp.decode('utf-8')), index_col=0)\n\n    ###############################################################################\n    # objMap (3d)\n    if doFile:\n        objMapFile = self._folder + self.name + '_objMap.txt'\n        if not os.path.isfile(objMapFile):\n            raise IOError(ENOENT, 'mmMap did not find objMapFile:', objMapFile)\n        # with open(objMapFile, 'rU') as f:\n        with open(objMapFile, 'r') as f:\n            header = f.readline().rstrip()\n        self.objMap = np.loadtxt(objMapFile, skiprows=1)\n    else:\n        tmp = self.server.getfile('objmap', self.name).decode(\"utf-8\")\n        header = tmp.split('\\n')[0]\n        self.objMap = np.loadtxt(tmp.split('\\n'), skiprows=1)\n\n    if header.endswith(';'):\n        header = header[:-1]\n    header = header.split(';')\n    d = dict(s.split('=') for s in header)\n    numRow = int(d['rows'])\n    numCol = int(d['cols'])\n    numBlock = int(d['blocks'])\n\n    self.objMap.resize(numBlock,numRow,numCol)\n    self.runMap = self._buildRunMap(self.objMap, roiTypeID=self.defaultAnnotationID)\n\n    ###############################################################################\n    # segMap (3d)\n    header = None\n    if doFile:\n        segMapFile = self._folder + self.name + '_segMap.txt'\n        if os.path.isfile(segMapFile):\n            # with open(segMapFile, 'rU') as f:\n            with open(segMapFile, 'r') as f:\n                header = f.readline().rstrip()\n            self.segMap = np.loadtxt(segMapFile, skiprows=1)\n        else:\n            #raise IOError(ENOENT, 'mmMap did not find segMapFile:', segMapFile)\n            print('did not find segment map file, should be ok')\n    else:\n        tmp = self.server.getfile('segmap', self.name).decode(\"utf-8\")\n        #header = tmp.split('\\r')[0] # works when server is running on OSX\n        header = tmp.split('\\n')[0]\n        self.segMap = np.loadtxt(tmp.split('\\n'), skiprows=1)\n\n    if header is not None:\n        if header.endswith(';'):\n            header = header[:-1]\n        header = header.split(';')\n        d = dict(s.split('=') for s in header)\n        numRow = int(d['rows'])\n        numCol = int(d['cols'])\n        numBlock = int(d['blocks'])\n\n        self.segMap.resize(numBlock,numRow,numCol)\n        self.segRunMap = self._buildRunMap(self.segMap, roiTypeID = None)\n\n    ###############################################################################\n    #load each stack db\n    # this assumes self.objMap has already been loaded\n    self._stacks = [] #  A list of mmStack\n    for _session in range(0, self.numSessions):\n        stackPath = self.getStackPath(_session)\n        stack = pymapmanager.stack(stackPath,\n                                   loadImageData=False,\n                                   mmMap=self,\n                                   mmMapSession=_session)\n        # if doFile:\n        #     stack = mmStack(name=self._getStackName(i), numChannels=self.numChannels, \\\n        #                     map=self, mapSession=i)\n        # else:\n        #     stack = mmStack(name=self._getStackName(i), numChannels=self.numChannels, \\\n        #                     map=self, mapSession=i, urlmap=self.name)\n        self.stacks.append(stack)\n\n    stopTime = time.time()\n    print('map', self.name, 'loaded in', round(stopTime-startTime,2), 'seconds.')\n\n    # 202402 need to add some columns to stack db\n    logger.warning('REMOVE THIS INGEST !!!!!!!!!')\n    from pymapmanager.interface2.mapWidgets._mapIngest import addDistance\n    addDistance(self)\n</code></pre>"},{"location":"api/map/#pymapmanager.mmMap.mmMap.getMapValues2","title":"<code>getMapValues2(stat, roiType=['spineROI'], segmentID=[], plotBad=False, plotIntBad=False)</code>","text":"<p>Get values of a stack annotation across all stacks in the map.</p> <p>Args:     stat (str): The stack annotation to get (corresponds to a column in mmStack.stackdb)     roiType (str): xxx     segmentID (list): xxx     plotBad (boolean): xxx</p> <p>Returns:     2D numpy array of stat values. Each row is a run of objects connected across sessions,     columns are sessions, each i is a stat value</p> Source code in <code>pymapmanager/mmMap.py</code> <pre><code>def getMapValues2(self, stat, roiType=['spineROI'], segmentID=[], plotBad=False, plotIntBad=False):\n    \"\"\"Get values of a stack annotation across all stacks in the map.\n\n    Args:\n        stat (str): The stack annotation to get (corresponds to a column in mmStack.stackdb)\n        roiType (str): xxx\n        segmentID (list): xxx\n        plotBad (boolean): xxx\n\n    Returns:\n        2D numpy array of stat values. Each row is a run of objects connected across sessions,\n        columns are sessions, each [i][j] is a stat value\n    \"\"\"\n\n    #if roiType not in ROI_TYPES:\n    #    errStr = 'error: mmMap.getMapValues2() stat \"' + roiType + '\" is not in ' + ','.join(ROI_TYPES)\n    #    raise h(errStr)\n\n    plotDict = newplotdict()\n    plotDict['roitype'] = roiType\n    plotDict['xstat'] = stat\n    plotDict['segmentid'] = segmentID\n    plotDict['plotbad'] = plotBad\n    plotDict['plotIntBad'] = plotIntBad\n\n    plotDict = self.getMapValues3(plotDict)\n\n    return plotDict['x']\n</code></pre>"},{"location":"api/map/#pymapmanager.mmMap.mmMap.getMapValues3","title":"<code>getMapValues3(pd)</code>","text":"<p>Get values of a stack annotation across all stacks in the map.</p> <p>Args:     pd (dict): A plot dictionary describing what to plot. Get default from mmUtil.newplotdict().</p> <p>Returns:</p> <pre><code>| pd['x'], 2D ndarray of xstat values, rows are runs, cols are sessions, nan is where there is no stackdb annotation\n| pd['y'], same\n| pd['z'], same\n| pd['stackidx'], Each [i]j[] gives the stack centric index of annotation value at [i][j].\n| pd['mapsess'], Each [i][j] gives the map session of value at annotation [i][j].\n| pd['runrow'],\n</code></pre> Source code in <code>pymapmanager/mmMap.py</code> <pre><code>def getMapValues3(self, pd):\n    \"\"\"Get values of a stack annotation across all stacks in the map.\n\n    Args:\n        pd (dict): A plot dictionary describing what to plot. Get default from mmUtil.newplotdict().\n\n    Returns:\n\n        | pd['x'], 2D ndarray of xstat values, rows are runs, cols are sessions, nan is where there is no stackdb annotation\n        | pd['y'], same\n        | pd['z'], same\n        | pd['stackidx'], Each [i]j[] gives the stack centric index of annotation value at [i][j].\n        | pd['mapsess'], Each [i][j] gives the map session of value at annotation [i][j].\n        | pd['runrow'],\n\n    \"\"\"\n    startTime = time.time()\n\n    # make sure pd['roitype'] is a list\n    if not isinstance(pd['roitype'], list):\n        pd['roitype'] = [pd['roitype']]\n\n    m = self.runMap.shape[0]\n    n = self.runMap.shape[1]\n\n    if pd['xstat']:\n        pd['x'] = np.empty([m, n])\n        pd['x'][:] = np.NAN\n    if pd['ystat']:\n        pd['y'] = np.empty([m, n])\n        pd['y'][:] = np.NAN\n    if pd['zstat']:\n        pd['z'] = np.empty([m, n])\n        pd['z'][:] = np.NAN\n\n    # keep track of stack centric index we are plotting\n    yIdx = np.empty([m, n])\n    yIdx[:] = np.NAN\n\n    # keep track of session index\n    ySess = np.empty([m, n])\n    ySess[:] = np.NAN\n\n    # keep track of run map rows (we already know the session/column)\n    yRunRow = np.empty([m, n])\n    yRunRow[:] = np.NAN\n\n    # always make a matrix of bad\n    isBad = np.empty([m, n])\n    isBad[:] = np.NAN\n\n    # keep track of map segment id\n    yMapSegment = []\n    if self.segMap is not None:\n        yMapSegment = np.empty([m, n])\n        yMapSegment[:] = np.NAN\n\n    # 20171225, cPnt is overkill but until I rewrite REST\n    # to get list of stat (x,y,z,pDist, cPnt, cx, cy, cz) etc. etc.\n    cPnt = np.empty([m, n])\n    cPnt[:] = np.NAN\n\n    runIdxDim = 6\n\n    if pd['stacklist'] is not None and len(pd['stacklist'])&gt;0:\n        myRange = pd['stacklist']\n    else:\n        myRange = range(n)\n\n    for j in myRange:\n\n        #print('*** getMapValues3() j:', j, \"pd['segmentid']:\", pd['segmentid'])\n        # orig_df = self.stacks[j].stackdb\n        orig_df = self.stacks[j].getPointAnnotations().getDataFrame()\n\n        # print(orig_df.columns)\n        # sys.exit(1)\n\n        currSegmentID = []\n        if self.numMapSegments &gt; 0:\n            # 20220103\n            oneSegment = pd['segmentid']\n            if isinstance(oneSegment, list):\n                logger.warning('abb 20220103 in mmMap.getMapValue3() fix this cludge from list to int')\n                if len(oneSegment) &gt; 0:\n                    oneSegment = oneSegment[0]\n                else:\n                    oneSegment = None\n            if oneSegment is not None and oneSegment &gt;=0 :\n                currSegmentID = self.segRunMap[oneSegment, j]  # this only works for one segment -- NOT A LIST\n                #print('   currSegmentID:', currSegmentID)\n                if currSegmentID &gt;= 0:\n                    currSegmentID = int(currSegmentID)\n                    # print 'getMapValues3() j:', j, 'currSegmentID:', currSegmentID\n                    currSegmentID = [currSegmentID]\n                else:\n                    currSegmentID = []\n            #print('   currSegmentID:', currSegmentID)\n            if oneSegment is not None and oneSegment &gt;= 0 and not currSegmentID:\n                # this session does not have segmentID that match\n                #print('   getMapValues3() skipping tp', j)\n                continue\n\n        goodIdx = self.runMap[:, j]  # valid indices from runMap\n\n        #print goodIdx\n\n        runMap_idx = orig_df.index.isin(goodIdx)  # series of boolean (Seems to play nice with nparray)\n\n        if pd['roitype']:\n            roiType_idx = orig_df['roiType'].isin(pd['roitype'])\n            runMap_idx = runMap_idx &amp; roiType_idx\n        if currSegmentID:\n            segmentID_idx = orig_df['segmentID'].isin(currSegmentID)\n            runMap_idx = runMap_idx &amp; segmentID_idx\n\n        # bad\n        if not pd['plotbad']:\n            #print('mmMap.getMapValues3() is stripping out isBad')\n            notBad_idx = ~orig_df['isBad'].isin([1])\n            runMap_idx = runMap_idx &amp; notBad_idx\n\n        # final_df = orig_df.loc[runMap_idx]\n        # 20210922 was this\n        #final_df = orig_df.ix[runMap_idx]\n        #print('20210922 orig_df:')\n        #print(orig_df)\n        final_df = orig_df.loc[runMap_idx]\n        #print(final_df)\n\n        # 20230523\n        _days = self.getValue('days', j)  # _days is a str\n        # logger.info(f'runMap_idx: {runMap_idx}')\n        final_df.loc[runMap_idx, 'days'] = _days\n\n        finalIndexList = final_df.index.tolist()\n\n        # we have a list of valid stack centric index in runMap_idx\n        # reverse this back into run centric to set rows in runMap (xPlot, yPlot)\n        # finalRows = self.objMap[runIdxDim,final_df.index,j]\n        finalRows = self.objMap[runIdxDim, finalIndexList, j]\n        finalRows = finalRows.astype(int)\n\n        #print 'getMapValues3() final_df:', final_df\n\n        # convert to values at end\n        try:\n            if pd['xstat'] and pd['xstat'] != 'session':\n                pd['x'][finalRows, j] = final_df[pd['xstat']].values\n            if pd['ystat']:\n                pd['y'][finalRows, j] = final_df[pd['ystat']].values\n            if pd['zstat']:\n                pd['z'][finalRows, j] = final_df[pd['zstat']].values\n        except (KeyError) as e:\n            logger.error(f'getMapValues3() KeyError - {e}')\n        # except:\n        #     print('getMapValues3() error in assignment')\n\n        # keep track of stack centric spine idx\n        yIdx[finalRows, j] = final_df.index.values\n        ySess[finalRows, j] = j\n        yRunRow[finalRows, j] = finalRows  # final_df.index\n\n        # bad\n        if pd['plotbad']:\n            bad_idx = final_df['isBad'].isin([1])\n            '''\n            if j == 3:\n                print(j, 'finalRows.shape:', finalRows.shape, finalRows.dtype)\n                print(j, 'bad_idx.shape:', bad_idx.shape, bad_idx.dtype)\n                print(final_df[['Idx', 'isBad']])\n            '''\n            isBad[finalRows, j] = bad_idx\n\n        #print 'a', final_df['parentID'].values.astype(int)\n        #print 'b', self.segMap[0, final_df['parentID'].values.astype(int), j]\n        if self.segMap is not None:\n            yMapSegment[finalRows, j] = self.segMap[0, final_df['segmentID'].values.astype(int), j]\n\n        cPnt[finalRows, j] = final_df['brightestIndex'].values\n\n        if pd['xstat'] == 'session':\n            #print 'swapping x for session'\n            pd['x'][finalRows, j] = j #ySess[finalRows,j]\n\n    # strip out all nan rows, can't do this until we have gone through all sessions\n    # makes plotting way faster\n    ySess = ySess[~np.isnan(yIdx).all(axis=1)]\n    yRunRow = yRunRow[~np.isnan(yIdx).all(axis=1)]\n    if pd['plotbad']:\n        isBad = isBad[~np.isnan(yIdx).all(axis=1)]\n    if self.segMap is not None:\n        yMapSegment = yMapSegment[~np.isnan(yIdx).all(axis=1)] # added 20171220\n    cPnt = cPnt[~np.isnan(yIdx).all(axis=1)] # added 20171225\n    if pd['xstat']:\n        pd['x'] = pd['x'][~np.isnan(yIdx).all(axis=1)]\n    if pd['ystat']:\n        pd['y'] = pd['y'][~np.isnan(yIdx).all(axis=1)]\n    if pd['zstat']:\n        pd['z'] = pd['z'][~np.isnan(yIdx).all(axis=1)]\n    yIdx = yIdx[~np.isnan(yIdx).all(axis=1)] # do this last\n\n\n    pd['stackidx'] = yIdx\n    pd['mapsess'] = ySess\n    pd['runrow'] = yRunRow\n    pd['mapsegment'] = yMapSegment\n    pd['cPnt'] = cPnt\n    if pd['plotbad']:\n        pd['isBad'] = isBad\n    else:\n        pd['isBad'] = None\n\n    if pd['getMapDynamics']:\n        # creates pd['dynamics']\n        pd = self.getMapDynamics(pd, thisMatrix=pd['stackidx'])\n\n    stopTime = time.time()\n    logger.info(f'   took:{round(stopTime - startTime, 2)} seconds')\n\n    return pd\n</code></pre>"},{"location":"api/map/#pymapmanager.mmMap.mmMap.getStackTimepoint","title":"<code>getStackTimepoint(thisStack)</code>","text":"<p>Given a stack, find the timepoint.</p> Source code in <code>pymapmanager/mmMap.py</code> <pre><code>def getStackTimepoint(self, thisStack : pymapmanager.stack) -&gt; int:\n    \"\"\"Given a stack, find the timepoint.\n    \"\"\" \n    for idx, stack in enumerate(self.stacks):\n        if stack == thisStack:\n            return idx\n    return None\n</code></pre>"},{"location":"api/map/#pymapmanager.mmMap.mmMap.getValue","title":"<code>getValue(name, sessionNumber)</code>","text":"<p>Get a value from the map (not from a stack!).</p> <p>Args:     name: Name of map value     sessionNumber: Session number of the stack</p> <p>Returns:     Str (this is a single value)</p> <p>Examples::</p> <pre><code>m.getValue('pixelsz', 2) # get the number of z-slices (pixels) of stack 2.\nm.getValue('voxelx', 5) # get the x voxel size of stack 5 (in um/pixel).\nm.getValue('hsStack',3) # get the name of stack 3.\n</code></pre> Source code in <code>pymapmanager/mmMap.py</code> <pre><code>def getValue(self, name, sessionNumber):\n    \"\"\"\n    Get a value from the map (not from a stack!).\n\n    Args:\n        name: Name of map value\n        sessionNumber: Session number of the stack\n\n    Returns:\n        Str (this is a single value)\n\n    Examples::\n\n        m.getValue('pixelsz', 2) # get the number of z-slices (pixels) of stack 2.\n        m.getValue('voxelx', 5) # get the x voxel size of stack 5 (in um/pixel).\n        m.getValue('hsStack',3) # get the name of stack 3.\n    \"\"\"\n    # .loc specifies row, .iloc specifies a column\n    return self.table.loc[name].iloc[sessionNumber]\n</code></pre>"},{"location":"api/map/#pymapmanager.mmMap.mmMap.mapInfo","title":"<code>mapInfo()</code>","text":"<p>Get information on the map</p> <p>Returns:     | A dict of     | mapName : Str     | numSessions : Int     | numChannels : Int     | numMapSegments : Int     |     | The following are string list with numSessions elements     | stackNames :     | importedStackName :     | numSlices :     | date :     | time :     | dx : Voxel size in um     | dy : Voxel size in um     | dz : Voxel size in um     | px : Number of Pixels     | py : Number of Pixels     | pz : Number of Pixels     | ...</p> Source code in <code>pymapmanager/mmMap.py</code> <pre><code>def mapInfo(self):\n    \"\"\"\n    Get information on the map\n\n    Returns:\n        | A dict of\n        | mapName : Str\n        | numSessions : Int\n        | numChannels : Int\n        | numMapSegments : Int\n        |\n        | The following are string list with numSessions elements\n        | stackNames :\n        | importedStackName :\n        | numSlices :\n        | date :\n        | time :\n        | dx : Voxel size in um\n        | dy : Voxel size in um\n        | dz : Voxel size in um\n        | px : Number of Pixels\n        | py : Number of Pixels\n        | pz : Number of Pixels\n        | ...\n    \"\"\"\n    theRet = {}\n    theRet['mapName'] = self.name\n    theRet['numSessions'] = self.numSessions\n    theRet['numChannels'] = self.numChannels\n    theRet['defaultAnnotation'] = self.defaultAnnotation\n    theRet['numAnnotations'] = 0\n    # lists, one value per session\n    theRet['stackNames'] = []\n    theRet['importedStackName'] = []\n    theRet['date'] = []\n    theRet['time'] = []\n    theRet['px'] = [] # pixels\n    theRet['py'] = []\n    theRet['numSlices'] = []\n    theRet['dx'] = [] # voxels in um\n    theRet['dy'] = []\n    theRet['dz'] = []\n    theRet['numROI'] = []\n    for idx in range(self.numSessions):\n        theRet['stackNames'].append(self.table.loc['hsStack'][idx])\n        theRet['importedStackName'].append(self.table.loc['importedStackName'][idx])\n        theRet['date'].append(self.table.loc['date'][idx])\n        theRet['time'].append(self.table.loc['time'][idx])\n        theRet['px'].append(self.table.loc['px'][idx])\n        theRet['py'].append(self.table.loc['py'][idx])\n        theRet['numSlices'].append(self.table.loc['pz'][idx]) # changing name\n\n        theRet['dx'].append(self.table.loc['dx'][idx])\n        theRet['dy'].append(self.table.loc['dy'][idx])\n        theRet['dz'].append(self.table.loc['dz'][idx])\n\n        thisNum = self.stacks[idx].countObj(roiType=self.defaultAnnotation)\n        theRet['numROI'].append(thisNum)\n        theRet['numAnnotations'] = theRet['numAnnotations'] + self.stacks[idx].numObj\n\n        runIdx = 6\n\n    if self.segMap is not None:\n        theRet['numMapSegments'] = self.segRunMap.shape[0]\n    else:\n        theRet['numMapSegments'] = 0\n\n    '''\n    # these were not being used\n    theRet['objMap'] = self.objMap[runIdx].astype('int') # from spine index to run index\n    theRet['runMap'] = self.runMap.astype('int') # from run idx to spine idx\n    theRet['segMap'] = None\n    theRet['numMapSegments'] = 0\n    if self.segMap is not None:\n        theRet['segMap'] = self.segMap.astype('int')\n        theRet['numMapSegments'] = self.segRunMap.shape[0]\n    '''\n\n    #print 'mapInfo() theRet:', theRet\n    return theRet\n</code></pre>"},{"location":"api/map/#pymapmanager.mmMap-functions","title":"Functions","text":""},{"location":"api/map/#pymapmanager.mmMap.newplotdict","title":"<code>newplotdict()</code>","text":"<p>Get a new default plot dictionary.</p> <p>The plot dictionary is used to tell plot functions what to plot (e.g. ['xtat'] and ['ystat']).</p> <p>All plot function return the same plot dictionary with keys filled in with values that were plotted (e.g. ['x'] and ['y']).</p> <p>Example::</p> <pre><code>import pymapmanager as pmm\n\npath = 'PyMapManager/examples/exampleMaps/rr30a/rr30a.txt'\nmap = pmm.mmMap(path)\nplotdict = pmm.mmUtil.newplotdict()\nplotdict['xstat'] = 'days'\nplotdict['ystat'] = 'pDist' # position of spine on its parent segment\nplotdict = map.getMapValues3(plotdict)\n\n# display with matplotlib\nplotdict['x']\nplotdict['y']\n</code></pre> Source code in <code>pymapmanager/mmMap.py</code> <pre><code>def newplotdict():\n    \"\"\"\n    Get a new default plot dictionary.\n\n    The plot dictionary is used to tell plot functions what to plot (e.g. ['xtat'] and ['ystat']).\n\n    All plot function return the same plot dictionary with keys filled in with values that were plotted\n    (e.g. ['x'] and ['y']).\n\n    Example::\n\n        import pymapmanager as pmm\n\n        path = 'PyMapManager/examples/exampleMaps/rr30a/rr30a.txt'\n        map = pmm.mmMap(path)\n        plotdict = pmm.mmUtil.newplotdict()\n        plotdict['xstat'] = 'days'\n        plotdict['ystat'] = 'pDist' # position of spine on its parent segment\n        plotdict = map.getMapValues3(plotdict)\n\n        # display with matplotlib\n        plotdict['x']\n        plotdict['y']\n\n    \"\"\"\n    return PLOT_DICT.copy()\n</code></pre>"},{"location":"api/overview/","title":"Overview","text":"<p>PyMapManager provides easy to use desktop and web GUIs. It also provides application programming interfaces (APIs).</p> <p>This is an overview of the APIs.</p>"},{"location":"api/stack/","title":"stack","text":"<p>A stack contains a an image and its corrresponding annotation.</p> <ul> <li>3D Tiff</li> <li>A list of point annotations,</li> <li>A number of line segment tracings.</li> </ul> <p>A stack can either be a single time-point or be embeded into a session (timepoint) of a :class:<code>pymapmanager.map</code>.</p> <p>The list of 3D annotations is a :class:<code>pymapmanager.annotations.pointAnnotations</code>.</p> <p>The list of line segments is a :class:<code>pymapmanager.annotations.lineAnnotations</code>.</p> <p>Stack annotations are saved in an enclosing folder with the same name as the tif stack file after removing the .tif extension.</p>"},{"location":"api/stack/#pymapmanager.stack-classes","title":"Classes","text":""},{"location":"api/stack/#pymapmanager.stack.pixelOrder","title":"<code>pixelOrder</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Specify the desired pixel order.</p> <p>This maps numpy (z, y, x).</p> Source code in <code>pymapmanager/stack.py</code> <pre><code>class pixelOrder(enum.Enum):\n    \"\"\"Specify the desired pixel order.\n\n    This maps numpy (z, y, x).\n    \"\"\"\n    xyz = [2, 1, 0]\n</code></pre>"},{"location":"api/stack/#pymapmanager.stack.stack","title":"<code>stack</code>","text":"<p>A stack manages:     i) A list of n-dimensional images (one image per color channel)     ii) A list of point annotations     iii) A list of line annotations</p> <p>Stacks are normally created by passing in a full path to a .tif file</p> <p>For 3D image data, we are assuming np.ndarray order of (slices, rows, cols)</p> <p>Notes:     - TODO (cudmore) we need a .txt json as a header     - stack does not know (row, col, slices) until loadImages()     - stack does not know (voxelx, voxely, voxelz) until loadAnnotations     - To remedy this, I have created a .txt file with some json Source code in <code>pymapmanager/stack.py</code> <pre><code>class stack():\n    \"\"\"\n    A stack manages:\n        i) A list of n-dimensional images (one image per color channel)\n        ii) A list of point annotations\n        iii) A list of line annotations\n\n    Stacks are normally created by passing in a full path to a .tif file\n\n    For 3D image data, we are assuming np.ndarray order of (slices, rows, cols)\n\n    Notes:\n        - TODO (cudmore) we need a &lt;file&gt;.txt json as a header\n        - stack does not know (row, col, slices) until loadImages()\n        - stack does not know (voxelx, voxely, voxelz) until loadAnnotations\n        - To remedy this, I have created a &lt;stack&gt;.txt file with some json\n    \"\"\"\n\n    maxNumChannels = 4\n    \"\"\"Maximum number of color channels. Corresponds to _ch1, _ch2, _ch3, etc\"\"\"\n\n    # ['_ch1.tif', '_ch2.tif', '_ch3.tif', '_ch4.tif']\n    channelStrings = [f'_ch{i}.tif' for i in range(1, maxNumChannels+1)]\n    \"\"\"Possible file name endings indicate color channels\"\"\"\n\n    # keep track of row order into numpy.ndarray\n    # TODO (cudmore) This is not always the case, we need to adapt to users data\n    imageSliceIdx = 0\n    imageRowIdx = 1\n    imageColIdx = 2\n\n    def __init__(self, path : str,\n                loadImageData : bool = True,\n                mmMap : \"pymapmanager.mmMap\" = None,\n                mmMapSession : int = None):\n        \"\"\"Create a stack from .tif file.\n\n        Args:\n            path (str): Full path to a tif file\n            loadImageData (bool): If True than load all channels image data\n\n        Notes:\n            - We need to load czi/lsm/nd2 using  aicsimageio\n            - If path ends with (_ch1.tif, _ch2.tif, _ch3.tif)\n                assume we are loading ScanImage tif after Fiji export to mapManager\n            - Look at all my recent work in Canvas repo to just load .tif etc native !\n        \"\"\"\n        if not os.path.isfile(path):\n            logger.error(f'Did not find tifPath: {path}')\n            # TODO (cudmore) is there a 'FileNotFound' exception built in?\n            raise OSError(errno.ENOENT, os.strerror(errno.ENOENT), path)\n\n        self._mmMap = mmMap\n        self._mmMapSession = mmMapSession\n\n        self._tifPath = path\n        \"\"\"Full path to .tif we were created with\"\"\"\n\n        self._basePath = self._getBasePath()\n        # full path after stripping (_ch1, _ch2, ...) and extension\n\n        self._baseName = os.path.split(self._basePath)[1]\n        # base file name after stripping (_ch1, _ch2, ...) and extension\n\n        self._enclosingPath = os.path.join(self._basePath, self._baseName)\n        # fill path to save files with (after appending something like '_la.txt)\n\n        self._numChannels, self._tifPathList = self._inferNumberOfChannels() \n        # infer this from tif file _ch (need to look on harddrive)\n\n        self._images = [None] * self.maxNumChannels\n        # List of n-dimensional images corresponding to potential _ch1, _ch2, _ch3, etc.\n        # Always keep a list of maxNumChannels and fill in depending on available files\n\n        self.brightestIndexesAreSet = False\n        # Boolean to ensure that brightest indexes are only set once\n\n        # When we do not load image data, we cannot infer header from tifData\n        imageShape = None\n        if loadImageData:\n            # load \n            for _channel in range(self.numChannels):\n                _channel += 1\n                imageShape = self.loadImages(channel=_channel)\n\n        # read from txt file json\n        headerDict = self.loadHeader()\n        if headerDict is not None:\n            self._header = headerDict\n        else:\n            logger.info(f'Creating header')\n            self._header = self._getDefaultHeader()\n            self._header['basename'] = self._baseName\n            self._header['numchannels'] = 2\n            # pixels\n            self._header['xPixels'] = imageShape[self.imageColIdx] if imageShape is not None else None\n            self._header['yPixels'] = imageShape[self.imageRowIdx] if imageShape is not None else None\n            self._header['zPixels'] = imageShape[self.imageSliceIdx] if imageShape is not None else None\n            # voxels (um per pixel)\n            # TODO (cudmore) Fix this fake default\n            self._header['xVoxel'] = 0.12\n            self._header['yVoxel'] = 0.12\n            self._header['zVoxel'] = 1\n            # width/height in um\n            self._header['umWidth'] = \\\n                self._header['xPixels'] * self._header['xVoxel'] if imageShape is not None else None\n            self._header['umHeight'] = \\\n                self._header['yPixels'] * self._header['yVoxel'] if imageShape is not None else None\n\n            self._header['bitDepth'] = 11\n\n        # TODO: in the future have analysis params be passed in so that each stack shares the same params.\n        self._analysisParams = AnalysisParams()\n\n        # TODO (cudmore) we should add an option to defer loading until explicitly called\n        self.loadLines()\n        self.loadAnnotations()\n        #self.loadLines()\n\n\n    def getMap(self):\n        return self._mmMap\n\n    def getFileName(self):\n        return os.path.split(self._tifPath)[1]\n\n    def getTifPath(self):\n        return self._tifPath\n\n    @property\n    def header(self) -&gt; dict:\n        return self._header\n\n    def __str__(self) -&gt; str:\n        \"\"\"Get the string representation of stack.\n        \"\"\"\n        printList = []\n        printList.append('stack')\n        printList.append(f'base name: {self._baseName}')\n        printList.append(f'channels: {self.numChannels}')\n        printList.append(f'slices: {self.numSlices}')\n        # printList.append(f'rows: {self.numImageRows}')\n        # printList.append(f'columns: {self.numImageColumns}')\n        printList.append(f'annotations: {self.getPointAnnotations().numAnnotations}')\n        printList.append(f'segments: {self.getLineAnnotations().numSegments}')\n\n        return ' '.join(printList)\n\n    def getMapSession(self):\n        \"\"\"Get stack session when in a map, otherwise None.\n        \"\"\"\n        return self._mmMapSession\n\n    def printHeader(self, prefixStr='  '):\n        logger.info(f'== header for stack {self._basePath}')\n        for k,v in self._header.items():\n            logger.info(f'  {prefixStr}{k} : {v} {type(v)}')\n\n    def getVoxelShape(self):\n        \"\"\"Get (slice, y, x) voxel shape in um (from header).\n        \"\"\"\n        xVoxel = self._header['xVoxel']\n        yVoxel = self._header['yVoxel']\n        zVoxel = self._header['zVoxel']\n        return zVoxel, yVoxel, xVoxel\n\n    def _getDefaultHeader(self) -&gt; dict:\n        \"\"\"\n        \"\"\"\n        headerDict = {\n            #'tifpath': '',\n            'basename': '',\n            'numchannels': 1,  # (int)\n            'xPixels': None,\n            'yPixels': None,\n            'zPixels': None,\n            'xVoxel': 1.0,  # (float)     \n            'yVoxel': 1.0,  # (float)     \n            'zVoxel': 1.0,  # (float)\n            'umWidth': None,\n            'umHeight': None  \n        }\n        return headerDict.copy()\n\n    def _getHeaderPath(self):\n        \"\"\"Get the full path to the stack header file.\n\n        This contains information about pixels, voxels, etc.\n        \"\"\"\n        folderPath = self._getEnclosingFolderPath()\n        headerFile = self._baseName + '.json'\n        headerPath = os.path.join(folderPath, headerFile)\n        return headerPath\n\n    def saveHeader(self):\n        \"\"\"Save the header dict as json.\n        \"\"\"\n        self._makeEnclosingFolder()\n\n        headerPath = self._getHeaderPath()\n        with open(headerPath, 'w') as outfile:\n            json.dump(self.header, outfile)\n        logger.info(f'Saved header {headerPath}')\n\n    def loadHeader(self) -&gt; dict:\n        \"\"\"Loader header json file into a dict.\n        \"\"\"\n        headerPath = self._getHeaderPath()\n        if os.path.isfile(headerPath):\n            logger.info(f'Loading header {headerPath}')\n            with open(headerPath) as json_file:\n                headerDict = json.load(json_file)\n            return headerDict\n        else:\n            logger.info(f'Did not find header file {headerPath}')\n            return None\n\n    def saveAs(self):\n        annotationFilePath = self._enclosingPath + '_pa.txt'\n        self.getPointAnnotations().saveAs(annotationFilePath)\n\n        lineFilePath = self._enclosingPath + '_la.txt'\n        self.getLineAnnotations().saveAs(lineFilePath)\n\n    def save(self, saveImages : bool = False):\n        \"\"\"Save line and point annotations.\n\n        TODO: Maybe also save tif data?\n        \"\"\"\n        self._makeEnclosingFolder()  # just in case\n        self.saveHeader()  # not really neccessary (does not change)\n\n        self.getLineAnnotations().save()\n        self.getPointAnnotations().save()\n\n        if saveImages:\n            # we generally never do this\n            pass\n\n    def loadImages(self, channel : int = None):\n        \"\"\"Load images associated with one channel.\n\n        Args:\n            channel (int):\n                If None then assume .tif file has no channel and our images data is just one channel.\n        \"\"\"\n        if channel is not None:\n            channelIdx = channel -1  # arguments channel is 1 based, real channels are 0 based\n            tifPath = self._basePath\n            tifPath += self.channelStrings[channelIdx]\n\n        if not os.path.isfile(tifPath):\n            logger.error(f'Did not find tif file at {tifPath}')\n            return None\n        else:\n            # TODO (cudmore) check if data is already loaded\n            tifData = tifffile.imread(tifPath)\n            self._images[channelIdx] = tifData\n            logger.info(f'Loaded tif data {tifData.shape} from tif file: {tifPath}')\n            return tifData.shape\n\n    def _old_getStack(self, channel : int = 1) -&gt; Optional[np.ndarray]:\n        \"\"\"Get the full image volume for one color channel.\n        \"\"\"\n        channelIdx = channel - 1\n        try:\n            return self._images[channelIdx]\n        except (IndexError) as e:\n            logger.warning(f'Max channel is {self.numChannels}')\n            return None\n\n    def getImageChannel(self,\n                        channel : int = 1\n                        ) -&gt; Optional[np.ndarray]:\n        \"\"\"Get the full image volume for one color channel.\n        \"\"\"\n\n        # TODO (Cudmore) fix\n        if channel is None:\n            channel = 1\n\n        channelIdx = channel - 1\n        try:\n            return self._images[channelIdx]\n        except (IndexError) as e:\n            logger.warning(f'Max channel is {self.numChannels}')\n            return None\n\n    def getImageSlice(self,\n                      imageSlice : int,\n                      channel : int = 1\n                      ) -&gt; Optional[np.ndarray]:\n        \"\"\"Get a single image slice from a channel.\n\n        Args:\n            slice (int): Image slice. Zero based\n            channel (int): Channel number, one based\n        \"\"\"\n\n        if not isinstance(imageSlice, int):\n            # print(\"Not an integer\")\n            imageSlice = int(imageSlice)\n\n        channelIdx = channel - 1\n        if self._images[channelIdx] is None:\n            logger.error(f'channel index {channelIdx} is None')\n            return\n        data =  self._images[channelIdx][imageSlice][:][:]\n        return data\n\n    def getMaxProject(self, channel : int = 1) -&gt; Optional[np.ndarray]:\n        \"\"\"Get a maximal intensity projection of image slices for one channel.\n        \"\"\"\n        channelIdx = channel - 1\n        if self._images[channelIdx] is None:\n            logger.error(f'channel {channelIdx} is None')\n            return\n\n        return self._images[channelIdx].max(axis=self.imageSliceIdx)\n\n    def getMaxProjectSlice(self, \n                            imageSlice : int, \n                            channel : int = 1, \n                            upSlices : int = 3, \n                            downSlices : int = 3,\n                            func = np.max\n                            ) -&gt; Optional[np.ndarray]:\n        \"\"\"Get a maximal intensity projection of image slices for one channel.\n\n        Args:\n            imageSlice:\n            channel:\n            upSlices:\n            downSlices:\n            func: Reference to np funtion to use like np.max\n        \"\"\"\n\n        if not isinstance(imageSlice, int):\n            #logger.warning('not an integer, converting')\n            imageSlice = int(imageSlice)\n\n        channelIdx = channel - 1\n\n        firstSlice = imageSlice - upSlices\n        if firstSlice &lt; 0:\n            firstSlice = 0\n\n        lastSlice = imageSlice + downSlices\n        if lastSlice &gt; self.numSlices - 1:\n            lastSlice = self.numSlices\n\n        if lastSlice == firstSlice:\n            # handles case where up/down is 0\n            return self._images[channelIdx][firstSlice]\n        else:\n            try:\n                theRet = self._images[channelIdx][firstSlice:lastSlice].max(axis=self.imageSliceIdx)\n            except (ValueError) as e:\n                logger.error(f'upSlices:{upSlices} downSlices:{downSlices} firstSlice:{firstSlice} lastSlice:{lastSlice}')\n                return\n\n        return theRet\n\n    def getPixel(self, channel : int, imageSlice : int, y, x) -&gt; int:\n        \"\"\"Get the intensity of a pixel.\n\n        TODO: Need to get from max project if we are showing that\n        \"\"\"\n        _image = self.getImageSlice(imageSlice=imageSlice, channel=channel)\n        if _image is None:\n            return np.nan\n        try:\n            _intensity = _image[y,x]\n        except (IndexError) as e:\n            #logger.error(f'IndexError x:{x} y:{y}')\n            return np.nan\n        return _intensity\n\n    @property\n    def numChannels(self) -&gt; int:\n        \"\"\"Get the number of color channels in the stack.\n        \"\"\"\n        return self._numChannels\n\n    @property\n    def numSlices(self) -&gt; int:\n        \"\"\"Get the number of images in the stack.\n        \"\"\"\n        numSlices = self._header['zPixels']\n        return numSlices\n\n    @property\n    def analysisParams(self) -&gt; AnalysisParams:\n        return self._analysisParams\n\n    def loadAnnotations(self) -&gt; None:\n        \"\"\"Load point annotations.\n        \"\"\"\n        try:            \n            annotationFilePath = self._enclosingPath + '_pa.txt'\n            # TODO: add detectionParamClass\n            self._annotations = pymapmanager.annotations.pointAnnotations(self, self._lines, annotationFilePath, analysisParams = self._analysisParams)\n        except (FileNotFoundError) as e:\n            self._annotations = None\n\n    def loadLines(self) -&gt; None:\n        \"\"\"Load line annotations.\n        \"\"\"\n        try:\n            lineFilePath = self._enclosingPath + '_la.txt'\n            # OLD: self._lines = pymapmanager.annotations.lineAnnotations(lineFilePath)\n            self._lines = pymapmanager.annotations.lineAnnotations(lineFilePath , analysisParams = self._analysisParams)\n        except (FileNotFoundError) as e:\n            self._lines = None\n\n    def getPointAnnotations(self) -&gt; pymapmanager.annotations.pointAnnotations:\n        return self._annotations\n\n    def createPaUUID(self):\n        self._annotations.createUUID()\n\n    def getLineAnnotations(self) -&gt; pymapmanager.annotations.lineAnnotations:\n        return self._lines\n\n    def _inferNumberOfChannels(self):\n        \"\"\"Infer the number of channels from existing files ending in _ch&lt;n&gt;.tif\n\n        Note: Sometimes user will have a _ch2.tif file but no corresponding _ch1.tif\n                In this case there is only one channel\n        \"\"\"\n        tifPathList = []\n        numChannels = 0\n        if not self._pathHasChannelStr():\n            # just one tif file\n            numChannels = 1\n            tifPathList = [self._tifPath]\n        else:\n            for chStr in self.channelStrings:\n                potentialTiffPath = self._basePath + chStr\n                if os.path.isfile(potentialTiffPath):\n                    numChannels += 1\n                    tifPathList.append(potentialTiffPath)\n        return numChannels, tifPathList\n\n    def _pathHasChannelStr(self):\n        \"\"\"Determine if path to tif ends in a _ch str\n        \"\"\"\n        path = self._tifPath\n        for chStr in self.channelStrings:\n            if path.endswith(chStr):\n                return True\n        return False\n\n    def _getBasePath(self):\n        \"\"\"Get base filename by removing all `self.channelStrings`\n\n        TODO (cudmore) Just do this once, it does not change.\n        \"\"\"\n        basePath = self._tifPath\n        # remove all _ch strings and .tif\n        for channelString in self.channelStrings:\n            basePath = basePath.replace(channelString, '')\n        return basePath\n\n    def _makeEnclosingFolder(self):\n        \"\"\"Make a containing folder from base name to hold all anotations.\n        \"\"\"\n        if os.path.isdir(self._basePath):\n            #logger.info(f'Base folder already exists at {basePath}')\n            pass\n        else:\n            logger.info(f'Making enclosing folder: \"{self._basePath}\"')\n            os.mkdir(self._basePath)\n\n    def _getEnclosingFolderPath(self):\n        \"\"\"Get the full path to the enclosing folder.\n\n        This is the folder where we save all analysis for a given tif stack.\n        \"\"\"\n        tifFolder, tifFile = os.path.split(self._tifPath)\n        folderPath = os.path.join(tifFolder, self._baseName)\n        return folderPath\n\n    def createBrightestIndexes(self, channelNum):\n        \"\"\"For all spines find brightest indexes within the lines.\n\n        Notes:\n        Temporary Quick Fix\n        Store brightest index in pointAnnotations \n        \"\"\"\n\n        if (self.brightestIndexesAreSet):\n            return \n\n        pas = self.getPointAnnotations()\n        las = self.getLineAnnotations()\n        segments = las.getSegmentList()\n        xyzSpines = []\n        brightestIndexes = []\n        # channel = self._channel\n        # channel = channelNum\n        # slice \n\n        # UI is slowed down now. This might be the cause.\n        # sliceImage = self.getImageSlice(imageSlice= ,\n        #                         channel=channelNum)\n\n        for segment in segments:\n            # print(\"segment is:\", segment)\n            # Get each line segement\n            dfLineSegment = las.getSegment(segment)\n\n            # Change this to have a backend function to simplify\n            startSegmentIndex = dfLineSegment['index'].to_numpy()[0]\n            lineSegment = dfLineSegment[['x', 'y', 'z']].to_numpy()\n\n            # Get the spines from each segment\n            dfSegmentSpines = pas.getSegmentSpines(segment)\n            # Iterate through all the spines \n            for idx, spine in dfSegmentSpines.iterrows():\n                # print(\"idx:\", idx)\n\n\n                xSpine = spine['x']\n                ySpine = spine['y']\n                zSpine = spine['z']\n                # ch2_img = myStack.getImageSlice(imageSlice=zSpine, channel=2)\n\n                sliceImage = self.getImageSlice(imageSlice= zSpine,\n                                channel=channelNum)\n\n                xyzSpines.append([xSpine, ySpine, zSpine])\n                # TODO: check if backend functions are working, check if image is actually correct\n                # Add brightestIndex in annotation as a column\n                brightestIndex = pymapmanager.utils._findBrightestIndex(xSpine, ySpine, zSpine, lineSegment, sliceImage)\n                brightestIndexes.append(brightestIndex + startSegmentIndex)\n\n                # Offset index accounts for inital index added onto the actual brightest index\n                offSetIndex = brightestIndex + startSegmentIndex\n                # spine['brightestIndex'] = offSetIndex\n                currentSpineRow = spine['index']\n                # print(\"currentSpineRow: \", currentSpineRow)\n                # print(\"brightestIndex: \", brightestIndex)\n                # print(\"startSegmentIndex: \", startSegmentIndex)\n                # print(\"offSetIndex: \", offSetIndex)\n                # print(type(offSetIndex))\n                # print(pas)\n                # sys.exit(1)\n\n                # Set the actual value into the backend (point annotations)\n                pas.setValue('brightestIndex', currentSpineRow, offSetIndex)\n                # pas.setValue('brightestIndex')\n\n                # print(\"spine:\", spine[\"index\"])\n                # This is used for debugging\n\n\n        # pas['brightestIndex'] = brightestIndexes\n\n        # for index, pa in pas:\n        #     pa['brightestIndex'] = brightestIndexes[index]\n\n        # self.brightestIndexesAreSet = True\n\n    def getNextPoint(self, stackDbIdx, leftRightStr):\n        \"\"\"Given a point, get the next/prev along a segment\n\n        TODO: Move this to stack and implement interface in stackWidget.\n        \"\"\"\n\n        pa = self.getPointAnnotations().getDataFrame()\n        la = self.getLineAnnotations().getFullDataFrame()\n\n        # check the point has a brightestIndex\n        # print('stackDbIdx:', stackDbIdx, type(stackDbIdx))\n\n        brightestIndex = pa['brightestIndex'].loc[stackDbIdx]\n        if np.isnan(brightestIndex):\n            roiType = pa['roiType'].loc[stackDbIdx]\n            logger.warning(f'point {stackDbIdx} {roiType} is not connected to a brightestIndex')\n            return\n\n        segmentID = pa['segmentID'].loc[stackDbIdx]\n\n        dfSegment = pa[ pa['segmentID'] == segmentID]\n\n        brightestIndex = int(brightestIndex)\n        startDist = la['aDist'].loc[brightestIndex]\n\n        nextIdx = None\n        if leftRightStr == 'left':\n            nextDist = 0\n            doRight = False\n        else:\n            nextDist = 2**16\n            doRight = True\n\n        for idx, rowDict in dfSegment.iterrows():\n            # print('idx:', idx, 'rowDict:', rowDict.keys())\n\n            currBrightestIndex = rowDict['brightestIndex']\n            if np.isnan(currBrightestIndex):\n                continue\n            currBrightestIndex = int(currBrightestIndex)\n            currDist = la['aDist'].loc[currBrightestIndex]\n            if doRight:\n                if (currDist &gt; startDist) and (currDist &lt; nextDist):\n                    nextIdx = idx\n                    nextDist = currDist\n            else:\n                if (currDist &lt; startDist) and (currDist &gt; nextDist):\n                    nextIdx = idx\n                    nextDist = currDist\n\n        logger.info(f'stackDbIdx is {stackDbIdx} startDist:{startDist}!!!')\n        logger.info(f'   nextIdx is {nextIdx} nextDist:{nextDist}!!!')\n\n        return nextIdx\n</code></pre>"},{"location":"api/stack/#pymapmanager.stack.stack-attributes","title":"Attributes","text":""},{"location":"api/stack/#pymapmanager.stack.stack.channelStrings","title":"<code>channelStrings = [f'_ch{i}.tif' for i in range(1, maxNumChannels + 1)]</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Possible file name endings indicate color channels</p>"},{"location":"api/stack/#pymapmanager.stack.stack.maxNumChannels","title":"<code>maxNumChannels = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximum number of color channels. Corresponds to _ch1, _ch2, _ch3, etc</p>"},{"location":"api/stack/#pymapmanager.stack.stack.numChannels","title":"<code>numChannels: int</code>  <code>property</code>","text":"<p>Get the number of color channels in the stack.</p>"},{"location":"api/stack/#pymapmanager.stack.stack.numSlices","title":"<code>numSlices: int</code>  <code>property</code>","text":"<p>Get the number of images in the stack.</p>"},{"location":"api/stack/#pymapmanager.stack.stack-functions","title":"Functions","text":""},{"location":"api/stack/#pymapmanager.stack.stack.__init__","title":"<code>__init__(path, loadImageData=True, mmMap=None, mmMapSession=None)</code>","text":"<p>Create a stack from .tif file.</p> <p>Args:     path (str): Full path to a tif file     loadImageData (bool): If True than load all channels image data</p> <p>Notes:     - We need to load czi/lsm/nd2 using  aicsimageio     - If path ends with (_ch1.tif, _ch2.tif, _ch3.tif)         assume we are loading ScanImage tif after Fiji export to mapManager     - Look at all my recent work in Canvas repo to just load .tif etc native !</p> Source code in <code>pymapmanager/stack.py</code> <pre><code>def __init__(self, path : str,\n            loadImageData : bool = True,\n            mmMap : \"pymapmanager.mmMap\" = None,\n            mmMapSession : int = None):\n    \"\"\"Create a stack from .tif file.\n\n    Args:\n        path (str): Full path to a tif file\n        loadImageData (bool): If True than load all channels image data\n\n    Notes:\n        - We need to load czi/lsm/nd2 using  aicsimageio\n        - If path ends with (_ch1.tif, _ch2.tif, _ch3.tif)\n            assume we are loading ScanImage tif after Fiji export to mapManager\n        - Look at all my recent work in Canvas repo to just load .tif etc native !\n    \"\"\"\n    if not os.path.isfile(path):\n        logger.error(f'Did not find tifPath: {path}')\n        # TODO (cudmore) is there a 'FileNotFound' exception built in?\n        raise OSError(errno.ENOENT, os.strerror(errno.ENOENT), path)\n\n    self._mmMap = mmMap\n    self._mmMapSession = mmMapSession\n\n    self._tifPath = path\n    \"\"\"Full path to .tif we were created with\"\"\"\n\n    self._basePath = self._getBasePath()\n    # full path after stripping (_ch1, _ch2, ...) and extension\n\n    self._baseName = os.path.split(self._basePath)[1]\n    # base file name after stripping (_ch1, _ch2, ...) and extension\n\n    self._enclosingPath = os.path.join(self._basePath, self._baseName)\n    # fill path to save files with (after appending something like '_la.txt)\n\n    self._numChannels, self._tifPathList = self._inferNumberOfChannels() \n    # infer this from tif file _ch (need to look on harddrive)\n\n    self._images = [None] * self.maxNumChannels\n    # List of n-dimensional images corresponding to potential _ch1, _ch2, _ch3, etc.\n    # Always keep a list of maxNumChannels and fill in depending on available files\n\n    self.brightestIndexesAreSet = False\n    # Boolean to ensure that brightest indexes are only set once\n\n    # When we do not load image data, we cannot infer header from tifData\n    imageShape = None\n    if loadImageData:\n        # load \n        for _channel in range(self.numChannels):\n            _channel += 1\n            imageShape = self.loadImages(channel=_channel)\n\n    # read from txt file json\n    headerDict = self.loadHeader()\n    if headerDict is not None:\n        self._header = headerDict\n    else:\n        logger.info(f'Creating header')\n        self._header = self._getDefaultHeader()\n        self._header['basename'] = self._baseName\n        self._header['numchannels'] = 2\n        # pixels\n        self._header['xPixels'] = imageShape[self.imageColIdx] if imageShape is not None else None\n        self._header['yPixels'] = imageShape[self.imageRowIdx] if imageShape is not None else None\n        self._header['zPixels'] = imageShape[self.imageSliceIdx] if imageShape is not None else None\n        # voxels (um per pixel)\n        # TODO (cudmore) Fix this fake default\n        self._header['xVoxel'] = 0.12\n        self._header['yVoxel'] = 0.12\n        self._header['zVoxel'] = 1\n        # width/height in um\n        self._header['umWidth'] = \\\n            self._header['xPixels'] * self._header['xVoxel'] if imageShape is not None else None\n        self._header['umHeight'] = \\\n            self._header['yPixels'] * self._header['yVoxel'] if imageShape is not None else None\n\n        self._header['bitDepth'] = 11\n\n    # TODO: in the future have analysis params be passed in so that each stack shares the same params.\n    self._analysisParams = AnalysisParams()\n\n    # TODO (cudmore) we should add an option to defer loading until explicitly called\n    self.loadLines()\n    self.loadAnnotations()\n</code></pre>"},{"location":"api/stack/#pymapmanager.stack.stack.__str__","title":"<code>__str__()</code>","text":"<p>Get the string representation of stack.</p> Source code in <code>pymapmanager/stack.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Get the string representation of stack.\n    \"\"\"\n    printList = []\n    printList.append('stack')\n    printList.append(f'base name: {self._baseName}')\n    printList.append(f'channels: {self.numChannels}')\n    printList.append(f'slices: {self.numSlices}')\n    # printList.append(f'rows: {self.numImageRows}')\n    # printList.append(f'columns: {self.numImageColumns}')\n    printList.append(f'annotations: {self.getPointAnnotations().numAnnotations}')\n    printList.append(f'segments: {self.getLineAnnotations().numSegments}')\n\n    return ' '.join(printList)\n</code></pre>"},{"location":"api/stack/#pymapmanager.stack.stack.createBrightestIndexes","title":"<code>createBrightestIndexes(channelNum)</code>","text":"<p>For all spines find brightest indexes within the lines.</p> <p>Notes: Temporary Quick Fix Store brightest index in pointAnnotations</p> Source code in <code>pymapmanager/stack.py</code> <pre><code>def createBrightestIndexes(self, channelNum):\n    \"\"\"For all spines find brightest indexes within the lines.\n\n    Notes:\n    Temporary Quick Fix\n    Store brightest index in pointAnnotations \n    \"\"\"\n\n    if (self.brightestIndexesAreSet):\n        return \n\n    pas = self.getPointAnnotations()\n    las = self.getLineAnnotations()\n    segments = las.getSegmentList()\n    xyzSpines = []\n    brightestIndexes = []\n    # channel = self._channel\n    # channel = channelNum\n    # slice \n\n    # UI is slowed down now. This might be the cause.\n    # sliceImage = self.getImageSlice(imageSlice= ,\n    #                         channel=channelNum)\n\n    for segment in segments:\n        # print(\"segment is:\", segment)\n        # Get each line segement\n        dfLineSegment = las.getSegment(segment)\n\n        # Change this to have a backend function to simplify\n        startSegmentIndex = dfLineSegment['index'].to_numpy()[0]\n        lineSegment = dfLineSegment[['x', 'y', 'z']].to_numpy()\n\n        # Get the spines from each segment\n        dfSegmentSpines = pas.getSegmentSpines(segment)\n        # Iterate through all the spines \n        for idx, spine in dfSegmentSpines.iterrows():\n            # print(\"idx:\", idx)\n\n\n            xSpine = spine['x']\n            ySpine = spine['y']\n            zSpine = spine['z']\n            # ch2_img = myStack.getImageSlice(imageSlice=zSpine, channel=2)\n\n            sliceImage = self.getImageSlice(imageSlice= zSpine,\n                            channel=channelNum)\n\n            xyzSpines.append([xSpine, ySpine, zSpine])\n            # TODO: check if backend functions are working, check if image is actually correct\n            # Add brightestIndex in annotation as a column\n            brightestIndex = pymapmanager.utils._findBrightestIndex(xSpine, ySpine, zSpine, lineSegment, sliceImage)\n            brightestIndexes.append(brightestIndex + startSegmentIndex)\n\n            # Offset index accounts for inital index added onto the actual brightest index\n            offSetIndex = brightestIndex + startSegmentIndex\n            # spine['brightestIndex'] = offSetIndex\n            currentSpineRow = spine['index']\n            # print(\"currentSpineRow: \", currentSpineRow)\n            # print(\"brightestIndex: \", brightestIndex)\n            # print(\"startSegmentIndex: \", startSegmentIndex)\n            # print(\"offSetIndex: \", offSetIndex)\n            # print(type(offSetIndex))\n            # print(pas)\n            # sys.exit(1)\n\n            # Set the actual value into the backend (point annotations)\n            pas.setValue('brightestIndex', currentSpineRow, offSetIndex)\n</code></pre>"},{"location":"api/stack/#pymapmanager.stack.stack.getImageChannel","title":"<code>getImageChannel(channel=1)</code>","text":"<p>Get the full image volume for one color channel.</p> Source code in <code>pymapmanager/stack.py</code> <pre><code>def getImageChannel(self,\n                    channel : int = 1\n                    ) -&gt; Optional[np.ndarray]:\n    \"\"\"Get the full image volume for one color channel.\n    \"\"\"\n\n    # TODO (Cudmore) fix\n    if channel is None:\n        channel = 1\n\n    channelIdx = channel - 1\n    try:\n        return self._images[channelIdx]\n    except (IndexError) as e:\n        logger.warning(f'Max channel is {self.numChannels}')\n        return None\n</code></pre>"},{"location":"api/stack/#pymapmanager.stack.stack.getImageSlice","title":"<code>getImageSlice(imageSlice, channel=1)</code>","text":"<p>Get a single image slice from a channel.</p> <p>Args:     slice (int): Image slice. Zero based     channel (int): Channel number, one based</p> Source code in <code>pymapmanager/stack.py</code> <pre><code>def getImageSlice(self,\n                  imageSlice : int,\n                  channel : int = 1\n                  ) -&gt; Optional[np.ndarray]:\n    \"\"\"Get a single image slice from a channel.\n\n    Args:\n        slice (int): Image slice. Zero based\n        channel (int): Channel number, one based\n    \"\"\"\n\n    if not isinstance(imageSlice, int):\n        # print(\"Not an integer\")\n        imageSlice = int(imageSlice)\n\n    channelIdx = channel - 1\n    if self._images[channelIdx] is None:\n        logger.error(f'channel index {channelIdx} is None')\n        return\n    data =  self._images[channelIdx][imageSlice][:][:]\n    return data\n</code></pre>"},{"location":"api/stack/#pymapmanager.stack.stack.getMapSession","title":"<code>getMapSession()</code>","text":"<p>Get stack session when in a map, otherwise None.</p> Source code in <code>pymapmanager/stack.py</code> <pre><code>def getMapSession(self):\n    \"\"\"Get stack session when in a map, otherwise None.\n    \"\"\"\n    return self._mmMapSession\n</code></pre>"},{"location":"api/stack/#pymapmanager.stack.stack.getMaxProject","title":"<code>getMaxProject(channel=1)</code>","text":"<p>Get a maximal intensity projection of image slices for one channel.</p> Source code in <code>pymapmanager/stack.py</code> <pre><code>def getMaxProject(self, channel : int = 1) -&gt; Optional[np.ndarray]:\n    \"\"\"Get a maximal intensity projection of image slices for one channel.\n    \"\"\"\n    channelIdx = channel - 1\n    if self._images[channelIdx] is None:\n        logger.error(f'channel {channelIdx} is None')\n        return\n\n    return self._images[channelIdx].max(axis=self.imageSliceIdx)\n</code></pre>"},{"location":"api/stack/#pymapmanager.stack.stack.getMaxProjectSlice","title":"<code>getMaxProjectSlice(imageSlice, channel=1, upSlices=3, downSlices=3, func=np.max)</code>","text":"<p>Get a maximal intensity projection of image slices for one channel.</p> <p>Args:     imageSlice:     channel:     upSlices:     downSlices:     func: Reference to np funtion to use like np.max</p> Source code in <code>pymapmanager/stack.py</code> <pre><code>def getMaxProjectSlice(self, \n                        imageSlice : int, \n                        channel : int = 1, \n                        upSlices : int = 3, \n                        downSlices : int = 3,\n                        func = np.max\n                        ) -&gt; Optional[np.ndarray]:\n    \"\"\"Get a maximal intensity projection of image slices for one channel.\n\n    Args:\n        imageSlice:\n        channel:\n        upSlices:\n        downSlices:\n        func: Reference to np funtion to use like np.max\n    \"\"\"\n\n    if not isinstance(imageSlice, int):\n        #logger.warning('not an integer, converting')\n        imageSlice = int(imageSlice)\n\n    channelIdx = channel - 1\n\n    firstSlice = imageSlice - upSlices\n    if firstSlice &lt; 0:\n        firstSlice = 0\n\n    lastSlice = imageSlice + downSlices\n    if lastSlice &gt; self.numSlices - 1:\n        lastSlice = self.numSlices\n\n    if lastSlice == firstSlice:\n        # handles case where up/down is 0\n        return self._images[channelIdx][firstSlice]\n    else:\n        try:\n            theRet = self._images[channelIdx][firstSlice:lastSlice].max(axis=self.imageSliceIdx)\n        except (ValueError) as e:\n            logger.error(f'upSlices:{upSlices} downSlices:{downSlices} firstSlice:{firstSlice} lastSlice:{lastSlice}')\n            return\n\n    return theRet\n</code></pre>"},{"location":"api/stack/#pymapmanager.stack.stack.getNextPoint","title":"<code>getNextPoint(stackDbIdx, leftRightStr)</code>","text":"<p>Given a point, get the next/prev along a segment</p> <p>TODO: Move this to stack and implement interface in stackWidget.</p> Source code in <code>pymapmanager/stack.py</code> <pre><code>def getNextPoint(self, stackDbIdx, leftRightStr):\n    \"\"\"Given a point, get the next/prev along a segment\n\n    TODO: Move this to stack and implement interface in stackWidget.\n    \"\"\"\n\n    pa = self.getPointAnnotations().getDataFrame()\n    la = self.getLineAnnotations().getFullDataFrame()\n\n    # check the point has a brightestIndex\n    # print('stackDbIdx:', stackDbIdx, type(stackDbIdx))\n\n    brightestIndex = pa['brightestIndex'].loc[stackDbIdx]\n    if np.isnan(brightestIndex):\n        roiType = pa['roiType'].loc[stackDbIdx]\n        logger.warning(f'point {stackDbIdx} {roiType} is not connected to a brightestIndex')\n        return\n\n    segmentID = pa['segmentID'].loc[stackDbIdx]\n\n    dfSegment = pa[ pa['segmentID'] == segmentID]\n\n    brightestIndex = int(brightestIndex)\n    startDist = la['aDist'].loc[brightestIndex]\n\n    nextIdx = None\n    if leftRightStr == 'left':\n        nextDist = 0\n        doRight = False\n    else:\n        nextDist = 2**16\n        doRight = True\n\n    for idx, rowDict in dfSegment.iterrows():\n        # print('idx:', idx, 'rowDict:', rowDict.keys())\n\n        currBrightestIndex = rowDict['brightestIndex']\n        if np.isnan(currBrightestIndex):\n            continue\n        currBrightestIndex = int(currBrightestIndex)\n        currDist = la['aDist'].loc[currBrightestIndex]\n        if doRight:\n            if (currDist &gt; startDist) and (currDist &lt; nextDist):\n                nextIdx = idx\n                nextDist = currDist\n        else:\n            if (currDist &lt; startDist) and (currDist &gt; nextDist):\n                nextIdx = idx\n                nextDist = currDist\n\n    logger.info(f'stackDbIdx is {stackDbIdx} startDist:{startDist}!!!')\n    logger.info(f'   nextIdx is {nextIdx} nextDist:{nextDist}!!!')\n\n    return nextIdx\n</code></pre>"},{"location":"api/stack/#pymapmanager.stack.stack.getPixel","title":"<code>getPixel(channel, imageSlice, y, x)</code>","text":"<p>Get the intensity of a pixel.</p> <p>TODO: Need to get from max project if we are showing that</p> Source code in <code>pymapmanager/stack.py</code> <pre><code>def getPixel(self, channel : int, imageSlice : int, y, x) -&gt; int:\n    \"\"\"Get the intensity of a pixel.\n\n    TODO: Need to get from max project if we are showing that\n    \"\"\"\n    _image = self.getImageSlice(imageSlice=imageSlice, channel=channel)\n    if _image is None:\n        return np.nan\n    try:\n        _intensity = _image[y,x]\n    except (IndexError) as e:\n        #logger.error(f'IndexError x:{x} y:{y}')\n        return np.nan\n    return _intensity\n</code></pre>"},{"location":"api/stack/#pymapmanager.stack.stack.getVoxelShape","title":"<code>getVoxelShape()</code>","text":"<p>Get (slice, y, x) voxel shape in um (from header).</p> Source code in <code>pymapmanager/stack.py</code> <pre><code>def getVoxelShape(self):\n    \"\"\"Get (slice, y, x) voxel shape in um (from header).\n    \"\"\"\n    xVoxel = self._header['xVoxel']\n    yVoxel = self._header['yVoxel']\n    zVoxel = self._header['zVoxel']\n    return zVoxel, yVoxel, xVoxel\n</code></pre>"},{"location":"api/stack/#pymapmanager.stack.stack.loadAnnotations","title":"<code>loadAnnotations()</code>","text":"<p>Load point annotations.</p> Source code in <code>pymapmanager/stack.py</code> <pre><code>def loadAnnotations(self) -&gt; None:\n    \"\"\"Load point annotations.\n    \"\"\"\n    try:            \n        annotationFilePath = self._enclosingPath + '_pa.txt'\n        # TODO: add detectionParamClass\n        self._annotations = pymapmanager.annotations.pointAnnotations(self, self._lines, annotationFilePath, analysisParams = self._analysisParams)\n    except (FileNotFoundError) as e:\n        self._annotations = None\n</code></pre>"},{"location":"api/stack/#pymapmanager.stack.stack.loadHeader","title":"<code>loadHeader()</code>","text":"<p>Loader header json file into a dict.</p> Source code in <code>pymapmanager/stack.py</code> <pre><code>def loadHeader(self) -&gt; dict:\n    \"\"\"Loader header json file into a dict.\n    \"\"\"\n    headerPath = self._getHeaderPath()\n    if os.path.isfile(headerPath):\n        logger.info(f'Loading header {headerPath}')\n        with open(headerPath) as json_file:\n            headerDict = json.load(json_file)\n        return headerDict\n    else:\n        logger.info(f'Did not find header file {headerPath}')\n        return None\n</code></pre>"},{"location":"api/stack/#pymapmanager.stack.stack.loadImages","title":"<code>loadImages(channel=None)</code>","text":"<p>Load images associated with one channel.</p> <p>Args:     channel (int):         If None then assume .tif file has no channel and our images data is just one channel.</p> Source code in <code>pymapmanager/stack.py</code> <pre><code>def loadImages(self, channel : int = None):\n    \"\"\"Load images associated with one channel.\n\n    Args:\n        channel (int):\n            If None then assume .tif file has no channel and our images data is just one channel.\n    \"\"\"\n    if channel is not None:\n        channelIdx = channel -1  # arguments channel is 1 based, real channels are 0 based\n        tifPath = self._basePath\n        tifPath += self.channelStrings[channelIdx]\n\n    if not os.path.isfile(tifPath):\n        logger.error(f'Did not find tif file at {tifPath}')\n        return None\n    else:\n        # TODO (cudmore) check if data is already loaded\n        tifData = tifffile.imread(tifPath)\n        self._images[channelIdx] = tifData\n        logger.info(f'Loaded tif data {tifData.shape} from tif file: {tifPath}')\n        return tifData.shape\n</code></pre>"},{"location":"api/stack/#pymapmanager.stack.stack.loadLines","title":"<code>loadLines()</code>","text":"<p>Load line annotations.</p> Source code in <code>pymapmanager/stack.py</code> <pre><code>def loadLines(self) -&gt; None:\n    \"\"\"Load line annotations.\n    \"\"\"\n    try:\n        lineFilePath = self._enclosingPath + '_la.txt'\n        # OLD: self._lines = pymapmanager.annotations.lineAnnotations(lineFilePath)\n        self._lines = pymapmanager.annotations.lineAnnotations(lineFilePath , analysisParams = self._analysisParams)\n    except (FileNotFoundError) as e:\n        self._lines = None\n</code></pre>"},{"location":"api/stack/#pymapmanager.stack.stack.save","title":"<code>save(saveImages=False)</code>","text":"<p>Save line and point annotations.</p> <p>TODO: Maybe also save tif data?</p> Source code in <code>pymapmanager/stack.py</code> <pre><code>def save(self, saveImages : bool = False):\n    \"\"\"Save line and point annotations.\n\n    TODO: Maybe also save tif data?\n    \"\"\"\n    self._makeEnclosingFolder()  # just in case\n    self.saveHeader()  # not really neccessary (does not change)\n\n    self.getLineAnnotations().save()\n    self.getPointAnnotations().save()\n\n    if saveImages:\n        # we generally never do this\n        pass\n</code></pre>"},{"location":"api/stack/#pymapmanager.stack.stack.saveHeader","title":"<code>saveHeader()</code>","text":"<p>Save the header dict as json.</p> Source code in <code>pymapmanager/stack.py</code> <pre><code>def saveHeader(self):\n    \"\"\"Save the header dict as json.\n    \"\"\"\n    self._makeEnclosingFolder()\n\n    headerPath = self._getHeaderPath()\n    with open(headerPath, 'w') as outfile:\n        json.dump(self.header, outfile)\n    logger.info(f'Saved header {headerPath}')\n</code></pre>"},{"location":"api/stack/#pymapmanager.stack-functions","title":"Functions","text":""},{"location":"api/stack/#pymapmanager.stack.connectSpineToLine","title":"<code>connectSpineToLine()</code>","text":"<p>Find the brightest path (in the image) between a spineRoi (x,y,z) and a segment ID (list of (x,y,z))</p> Source code in <code>pymapmanager/stack.py</code> <pre><code>def connectSpineToLine():\n    \"\"\"Find the brightest path (in the image) between a spineRoi (x,y,z)\n        and a segment ID (list of (x,y,z))\n    \"\"\"\n\n    '''\n    For each spineRoi in point annotations\n        - grab that spine roi segmentID\n        - grab all (x,y,z) points in line annotation with segmentID\n\n        - find the closest point on the line (3d pythagrian theorem)\n        - for each point on the line within a number of points from the closest point\n            - draw a line between spineROI (x,y,z) and candidate on line annotation\n                - calculate the intensity along that line\n                - use: https://scikit-image.org/docs/stable/api/skimage.measure.html#skimage.measure.profile_line\n                - now you have a set of cadiate line and their intensities\n            - return the line (from the candidates) that has the brightest path\n    '''\n\n    stackPath = '../PyMapManager-Data/one-timepoint/rr30a_s0_ch2.tif'\n    myStack = stack(stackPath)\n    pas = myStack.getPointAnnotations()\n    las = myStack.getLineAnnotations()\n\n    #uniqueSegments = las.numSegments()\n    # for la in las:\n    #     print(la['segmentID'])\n\n\n    for pa in pas:\n        #print(pa)\n        if pa['roiType'] == 'spineROI':\n            segmentID = pa['segmentID']\n            #[_z, _y, _x, _index, _segmentID] = las.getSegment_xyz(segmentID=segmentID)\n            tmp = las.getSegment_xyz(segmentID=segmentID)\n            print(tmp)\n</code></pre>"},{"location":"api/writing-a-stack-plugin/","title":"Writing A Stack Plugin","text":"<p>Writing a stack plugin is easy</p> <p>1) Derive a class from mmWidget</p> <p>2) give it a name</p> <p>3) build UI by calling xxx</p> <p>4) respond to slots during runtime (like selection events)</p>"},{"location":"notebooks/load-a-map/","title":"Map Dendrogram","text":"<p>Load a map</p> In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n\nimport pymapmanager as pmm\n\n# load a map\nmapPath = '../../../../PyMapManager-Data/maps/rr30a/rr30a.txt'\nmap = pmm.mmMap(mapPath)\n\n# we need to work on this !!!!'ArithmeticError\n\nprint('hello world')\nprint(map)\n</pre> %load_ext autoreload %autoreload 2  import pymapmanager as pmm  # load a map mapPath = '../../../../PyMapManager-Data/maps/rr30a/rr30a.txt' map = pmm.mmMap(mapPath)  # we need to work on this !!!!'ArithmeticError  print('hello world') print(map)  <pre>   INFO - stack.py loadHeader() line:253 -- Loading header ../../../../PyMapManager-Data/maps/rr30a/rr30a_s0/rr30a_s0.json\nWARNING - baseAnnotations.py load() line:1297 -- class lineAnnotations did not find expected column name \"uniqueID\"\nWARNING - baseAnnotations.py load() line:1297 -- class pointAnnotations did not find expected column name \"uniqueID\"\nWARNING - baseAnnotations.py load() line:1322 -- Loaded with unknown column name \"spineROICoords\" in class \"pointAnnotations\"\nWARNING - baseAnnotations.py load() line:1322 -- Loaded with unknown column name \"segmentROICoords\" in class \"pointAnnotations\"\n   INFO - stack.py loadHeader() line:253 -- Loading header ../../../../PyMapManager-Data/maps/rr30a/rr30a_s1/rr30a_s1.json\nWARNING - baseAnnotations.py load() line:1297 -- class lineAnnotations did not find expected column name \"uniqueID\"\nWARNING - baseAnnotations.py load() line:1297 -- class pointAnnotations did not find expected column name \"uniqueID\"\nWARNING - baseAnnotations.py load() line:1322 -- Loaded with unknown column name \"spineROICoords\" in class \"pointAnnotations\"\nWARNING - baseAnnotations.py load() line:1322 -- Loaded with unknown column name \"segmentROICoords\" in class \"pointAnnotations\"\n   INFO - stack.py loadHeader() line:253 -- Loading header ../../../../PyMapManager-Data/maps/rr30a/rr30a_s2/rr30a_s2.json\nWARNING - baseAnnotations.py load() line:1297 -- class lineAnnotations did not find expected column name \"uniqueID\"\nWARNING - baseAnnotations.py load() line:1297 -- class pointAnnotations did not find expected column name \"uniqueID\"\nWARNING - baseAnnotations.py load() line:1322 -- Loaded with unknown column name \"spineROICoords\" in class \"pointAnnotations\"\nWARNING - baseAnnotations.py load() line:1322 -- Loaded with unknown column name \"segmentROICoords\" in class \"pointAnnotations\"\n   INFO - stack.py loadHeader() line:253 -- Loading header ../../../../PyMapManager-Data/maps/rr30a/rr30a_s3/rr30a_s3.json\nWARNING - baseAnnotations.py load() line:1297 -- class lineAnnotations did not find expected column name \"uniqueID\"\nWARNING - baseAnnotations.py load() line:1297 -- class pointAnnotations did not find expected column name \"uniqueID\"\nWARNING - baseAnnotations.py load() line:1322 -- Loaded with unknown column name \"spineROICoords\" in class \"pointAnnotations\"\nWARNING - baseAnnotations.py load() line:1322 -- Loaded with unknown column name \"segmentROICoords\" in class \"pointAnnotations\"\n   INFO - stack.py loadHeader() line:253 -- Loading header ../../../../PyMapManager-Data/maps/rr30a/rr30a_s4/rr30a_s4.json\nWARNING - baseAnnotations.py load() line:1297 -- class lineAnnotations did not find expected column name \"uniqueID\"\nWARNING - baseAnnotations.py load() line:1297 -- class pointAnnotations did not find expected column name \"uniqueID\"\nWARNING - baseAnnotations.py load() line:1322 -- Loaded with unknown column name \"spineROICoords\" in class \"pointAnnotations\"\nWARNING - baseAnnotations.py load() line:1322 -- Loaded with unknown column name \"segmentROICoords\" in class \"pointAnnotations\"\n   INFO - stack.py loadHeader() line:253 -- Loading header ../../../../PyMapManager-Data/maps/rr30a/rr30a_s5/rr30a_s5.json\nWARNING - baseAnnotations.py load() line:1297 -- class lineAnnotations did not find expected column name \"uniqueID\"\nWARNING - baseAnnotations.py load() line:1297 -- class pointAnnotations did not find expected column name \"uniqueID\"\nWARNING - baseAnnotations.py load() line:1322 -- Loaded with unknown column name \"spineROICoords\" in class \"pointAnnotations\"\nWARNING - baseAnnotations.py load() line:1322 -- Loaded with unknown column name \"segmentROICoords\" in class \"pointAnnotations\"\n   INFO - stack.py loadHeader() line:253 -- Loading header ../../../../PyMapManager-Data/maps/rr30a/rr30a_s6/rr30a_s6.json\nWARNING - baseAnnotations.py load() line:1297 -- class lineAnnotations did not find expected column name \"uniqueID\"\nWARNING - baseAnnotations.py load() line:1297 -- class pointAnnotations did not find expected column name \"uniqueID\"\nWARNING - baseAnnotations.py load() line:1322 -- Loaded with unknown column name \"spineROICoords\" in class \"pointAnnotations\"\nWARNING - baseAnnotations.py load() line:1322 -- Loaded with unknown column name \"segmentROICoords\" in class \"pointAnnotations\"\n   INFO - stack.py loadHeader() line:253 -- Loading header ../../../../PyMapManager-Data/maps/rr30a/rr30a_s7/rr30a_s7.json\nWARNING - baseAnnotations.py load() line:1297 -- class lineAnnotations did not find expected column name \"uniqueID\"\nWARNING - baseAnnotations.py load() line:1297 -- class pointAnnotations did not find expected column name \"uniqueID\"\nWARNING - baseAnnotations.py load() line:1322 -- Loaded with unknown column name \"spineROICoords\" in class \"pointAnnotations\"\nWARNING - baseAnnotations.py load() line:1322 -- Loaded with unknown column name \"segmentROICoords\" in class \"pointAnnotations\"\n   INFO - stack.py loadHeader() line:253 -- Loading header ../../../../PyMapManager-Data/maps/rr30a/rr30a_s8/rr30a_s8.json\nWARNING - baseAnnotations.py load() line:1297 -- class lineAnnotations did not find expected column name \"uniqueID\"\nWARNING - baseAnnotations.py load() line:1297 -- class pointAnnotations did not find expected column name \"uniqueID\"\nWARNING - baseAnnotations.py load() line:1322 -- Loaded with unknown column name \"spineROICoords\" in class \"pointAnnotations\"\nWARNING - baseAnnotations.py load() line:1322 -- Loaded with unknown column name \"segmentROICoords\" in class \"pointAnnotations\"\nmap rr30a loaded in 0.45 seconds.\nWARNING - mmMap.py __init__() line:297 -- REMOVE THIS INGEST !!!!!!!!!\nhello world\nmap:rr30a map segments:5 stacks:9 total object:2467\n</pre> <p>Plot a dendrogram</p> In\u00a0[2]: Copied! <pre>from pymapmanager.interface2.mapWidgets.mmMapPlot import plotDendrogram\n\nplotDendrogram(map, fig=None)\n</pre> from pymapmanager.interface2.mapWidgets.mmMapPlot import plotDendrogram  plotDendrogram(map, fig=None) <pre>   INFO - mmMap.py getMapValues3() line:843 --    took:0.02 seconds\n   INFO - mmMapPlot.py _refreshFigure() line:650 -- \n   INFO - mmMapPlot.py togglelines() line:729 -- onoff:True showLines:True\n   INFO - mmMapPlot.py _refreshFigure() line:650 -- \n   INFO - mmMapPlot.py _refreshFigure() line:650 -- \n</pre>"}]}